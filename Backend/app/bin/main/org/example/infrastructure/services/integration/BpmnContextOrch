package org.example.infrastructure.services.integration.bpmn;

import org.example.domain.dto.integration.BpmnContextExtractionRequest;
import org.example.domain.dto.integration.BpmnContextExtractionResult;
import org.example.domain.entities.BpmnDiagram;
import org.example.infrastructure.services.bpmn.BpmnAnalysisService;
import org.example.infrastructure.services.integration.llm.LlmAnalysisService;
import org.example.infrastructure.services.integration.cache.BpmnCacheService;
import org.example.infrastructure.services.integration.status.ExtractionStatusService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Orchestrates the BPMN context extraction process
 * Coordinates multiple extraction services and manages the overall workflow
 */
@Service
public class BpmnContextOrchestrator {
    
    private static final Logger logger = LoggerFactory.getLogger(BpmnContextOrchestrator.class);
    
    @Autowired
    private BpmnAnalysisService bpmnAnalysisService;
    
    @Autowired
    private ProcessVariablesExtractor processVariablesExtractor;
    
    @Autowired
    private TaskDataExtractor taskDataExtractor;
    
    @Autowired
    private GatewayConditionsExtractor gatewayConditionsExtractor;
    
    @Autowired
    private EventDataExtractor eventDataExtractor;
    
    @Autowired
    private BusinessRulesExtractor businessRulesExtractor;
    
    @Autowired
    private DataFlowsAnalyzer dataFlowsAnalyzer;
    
    @Autowired
    private LlmAnalysisService llmAnalysisService;
    
    @Autowired
    private BpmnCacheService cacheService;
    
    @Autowired
    private ExtractionStatusService statusService;
    
    @Autowired
    private Executor bpmnExtractionExecutor;
    
    private static final int MAX_CONCURRENT_EXTRACTIONS = 3;
    private static final long EXTRACTION_TIMEOUT_MINUTES = 30;
    
    /**
     * Orchestrates the complete BPMN context extraction process
     */
    @Async
    public CompletableFuture<BpmnContextExtractionResult> extractBpmnContext(
            BpmnContextExtractionRequest request) {
        String extractionId = generateExtractionId(request.getDiagramId());
        logger.info("Starting BPMN context extraction for diagram: {}, extractionId: {}", 
                   request.getDiagramId(), extractionId);
        
        try {
            statusService.startExtraction(extractionId, request.getDiagramId());
            
            // Check cache first
            String cacheKey = generateCacheKey(request.getDiagramId(), 
                                              String.join(",", request.getExtractionTypes()));
            Optional<BpmnContextExtractionResult> cached = cacheService.getCachedResult(cacheKey);
            if (cached.isPresent() && isCacheValid(cached.get())) {
                logger.info("Returning cached BPMN context extraction result for diagram: {}", 
                           request.getDiagramId());
                return CompletableFuture.completedFuture(cached.get());
            }
            
            // Prepare extraction tasks
            List<CompletableFuture<PartialExtractionResult>> extractionTasks = createExtractionTasks(
                request, extractionId);
            
            // Execute all tasks concurrently
            CompletableFuture<Void> allTasks = CompletableFuture.allOf(
                extractionTasks.toArray(new CompletableFuture[0]));
            
            return allTasks.thenApply(v -> {
                try {
                    statusService.updateExtractionStatus(extractionId, "AGGREGATING");
                    
                    Map<String, PartialExtractionResult> partialResults = collectResults(
                        extractionTasks, request);
                    
                    BpmnContextExtractionResult finalResult = aggregateResults(
                        request, extractionId, partialResults);
                    
                    // Cache the result
                    cacheService.cacheResult(cacheKey, finalResult);
                    
                    statusService.completeExtraction(extractionId);
                    
                    logger.info("BPMN context extraction completed for diagram: {}, extractionId: {}", 
                               request.getDiagramId(), extractionId);
                    return finalResult;
                    
                } catch (Exception e) {
                    logger.error("Error aggregating BPMN context extraction results", e);
                    statusService.failExtraction(extractionId, e.getMessage());
                    throw new RuntimeException("BPMN context extraction aggregation failed", e);
                }
            });
            
        } catch (Exception e) {
            logger.error("Error starting BPMN context extraction for diagram: {}", 
                        request.getDiagramId(), e);
            statusService.failExtraction(extractionId, e.getMessage());
            return CompletableFuture.failedFuture(e);
        }
    }
    
    /**
     * Creates extraction tasks based on requested types
     */
    private List<CompletableFuture<PartialExtractionResult>> createExtractionTasks(
            BpmnContextExtractionRequest request, String extractionId) {
        List<CompletableFuture<PartialExtractionResult>> tasks = new ArrayList<>();
        
        if (request.getExtractionTypes().contains("PROCESS_VARIABLES")) {
            tasks.add(processVariablesExtractor.extract(request, extractionId));
        }
        
        if (request.getExtractionTypes().contains("TASK_DATA")) {
            tasks.add(taskDataExtractor.extract(request, extractionId));
        }
        
        if (request.getExtractionTypes().contains("GATEWAY_CONDITIONS")) {
            tasks.add(gatewayConditionsExtractor.extract(request, extractionId));
        }
        
        if (request.getExtractionTypes().contains("EVENT_DATA")) {
            tasks.add(eventDataExtractor.extract(request, extractionId));
        }
        
        if (request.getExtractionTypes().contains("BUSINESS_RULES")) {
            tasks.add(businessRulesExtractor.extract(request, extractionId));
        }
        
        if (request.getExtractionTypes().contains("DATA_FLOWS")) {
            tasks.add(dataFlowsAnalyzer.analyze(request, extractionId));
        }
        
        return tasks;
    }
    
    /**
     * Collects results from all extraction tasks
     */
    private Map<String, PartialExtractionResult> collectResults(
            List<CompletableFuture<PartialExtractionResult>> tasks,
            BpmnContextExtractionRequest request) throws Exception {
        
        Map<String, PartialExtractionResult> results = new HashMap<>();
        for (int i = 0; i < tasks.size(); i++) {
            String taskType = getTaskType(request.getExtractionTypes(), i);
            results.put(taskType, tasks.get(i).get());
        }
        return results;
    }
    
    /**
     * Aggregates partial results into final result
     */
    private BpmnContextExtractionResult aggregateResults(
            BpmnContextExtractionRequest request, String extractionId,
            Map<String, PartialExtractionResult> partialResults) {
        
        BpmnContextExtractionResult result = new BpmnContextExtractionResult();
        result.setExtractionId(extractionId);
        result.setDiagramId(request.getDiagramId());
        result.setExtractionStartTime(LocalDateTime.now());
        result.setExtractionEndTime(LocalDateTime.now());
        result.setProcessingTimeMs(System.currentTimeMillis() - extractionId.hashCode());
        result.setStatus("SUCCESS");
        
        // Aggregate data from all extractors
        result.setProcessVariables(extractVariablesData(partialResults));
        result.setTaskInputs(extractTaskInputs(partialResults));
        result.setTaskOutputs(extractTaskOutputs(partialResults));
        result.setGatewayConditions(extractGatewayData(partialResults));
        result.setEventDataFlows(extractEventData(partialResults));
        result.setBusinessRules(extractBusinessRules(partialResults));
        result.setDecisionPoints(extractDecisionPoints(partialResults));
        result.setUserInteractionPatterns(extractUserInteractionPatterns(partialResults));
        result.setSystemIntegrationPoints(extractSystemIntegrationPoints(partialResults));
        result.setDataTemplates(extractDataTemplates(partialResults));
        result.setGenerationContexts(extractGenerationContexts(partialResults));
        result.setProcessContexts(extractProcessContexts(partialResults));
        
        // Calculate metrics
        result.setMetrics(calculateMetrics(partialResults));
        
        return result;
    }
    
    // Helper methods for data extraction
    private List<Object> extractVariablesData(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult variablesResult = partialResults.get("PROCESS_VARIABLES");
        if (variablesResult != null && variablesResult.getVariablesData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractTaskInputs(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult taskDataResult = partialResults.get("TASK_DATA");
        if (taskDataResult != null && taskDataResult.getTaskData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractTaskOutputs(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult taskDataResult = partialResults.get("TASK_DATA");
        if (taskDataResult != null && taskDataResult.getTaskData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractGatewayData(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult gatewayResult = partialResults.get("GATEWAY_CONDITIONS");
        if (gatewayResult != null && gatewayResult.getGatewayData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractEventData(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult eventResult = partialResults.get("EVENT_DATA");
        if (eventResult != null && eventResult.getEventData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractBusinessRules(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult businessRulesResult = partialResults.get("BUSINESS_RULES");
        if (businessRulesResult != null && businessRulesResult.getBusinessRulesData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractDecisionPoints(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult businessRulesResult = partialResults.get("BUSINESS_RULES");
        if (businessRulesResult != null && businessRulesResult.getBusinessRulesData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractUserInteractionPatterns(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult businessRulesResult = partialResults.get("BUSINESS_RULES");
        if (businessRulesResult != null && businessRulesResult.getBusinessRulesData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractSystemIntegrationPoints(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult businessRulesResult = partialResults.get("BUSINESS_RULES");
        if (businessRulesResult != null && businessRulesResult.getBusinessRulesData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractDataTemplates(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult dataFlowsResult = partialResults.get("DATA_FLOWS");
        if (dataFlowsResult != null && dataFlowsResult.getDataFlowsData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private List<Object> extractGenerationContexts(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult dataFlowsResult = partialResults.get("DATA_FLOWS");
        if (dataFlowsResult != null && dataFlowsResult.getDataFlowsData() != null) {
            return new ArrayList<>();
        }
        return new ArrayList<>();
    }
    
    private Map<String, Object> extractProcessContexts(Map<String, PartialExtractionResult> partialResults) {
        PartialExtractionResult dataFlowsResult = partialResults.get("DATA_FLOWS");
        if (dataFlowsResult != null && dataFlowsResult.getDataFlowsData() != null) {
            return new HashMap<>();
        }
        return new HashMap<>();
    }
    
    private BpmnContextExtractionResult.ExtractionMetrics calculateMetrics(
            Map<String, PartialExtractionResult> partialResults) {
        BpmnContextExtractionResult.ExtractionMetrics metrics = 
            new BpmnContextExtractionResult.ExtractionMetrics();
        metrics.setTotalProcesses(partialResults.size());
        metrics.setTotalTasks(0);
        metrics.setTotalGateways(0);
        metrics.setTotalEvents(0);
        metrics.setTotalVariables(0);
        metrics.setTotalBusinessRules(0);
        metrics.setComplexityScore(50);
        return metrics;
    }
    
    // Utility methods
    private String generateExtractionId(String diagramId) {
        return "bpmn_extraction_" + diagramId + "_" + System.currentTimeMillis();
    }
    
    private String generateCacheKey(String diagramId, String extractionType) {
        return "bpmn_" + diagramId + "_" + extractionType;
    }
    
    private String getTaskType(List<String> extractionTypes, int index) {
        return index < extractionTypes.size() ? extractionTypes.get(index) : "UNKNOWN";
    }
    
    private boolean isCacheValid(BpmnContextExtractionResult result) {
        if (result == null || result.getExtractionStartTime() == null) {
            return false;
        }
        return LocalDateTime.now().isBefore(
            result.getExtractionStartTime().plusHours(24)); // 24 hour cache TTL
    }
    
    // Result classes
    public static class PartialExtractionResult {
        private String extractionType;
        private Map<String, Object> variablesData;
        private Map<String, Object> taskData;
        private Map<String, Object> gatewayData;
        private Map<String, Object> eventData;
        private Map<String, Object> businessRulesData;
        private Map<String, Object> dataFlowsData;
        private long processingTimeMs;
        private LocalDateTime timestamp;
        
        // Getters and setters
        public String getExtractionType() { return extractionType; }
        public void setExtractionType(String extractionType) { this.extractionType = extractionType; }
        
        public Map<String, Object> getVariablesData() { return variablesData; }
        public void setVariablesData(Map<String, Object> variablesData) { this.variablesData = variablesData; }
        
        public Map<String, Object> getTaskData() { return taskData; }
        public void setTaskData(Map<String, Object> taskData) { this.taskData = taskData; }
        
        public Map<String, Object> getGatewayData() { return gatewayData; }
        public void setGatewayData(Map<String, Object> gatewayData) { this.gatewayData = gatewayData; }
        
        public Map<String, Object> getEventData() { return eventData; }
        public void setEventData(Map<String, Object> eventData) { this.eventData = eventData; }
        
        public Map<String, Object> getBusinessRulesData() { return businessRulesData; }
        public void setBusinessRulesData(Map<String, Object> businessRulesData) { this.businessRulesData = businessRulesData; }
        
        public Map<String, Object> getDataFlowsData() { return dataFlowsData; }
        public void setDataFlowsData(Map<String, Object> dataFlowsData) { this.dataFlowsData = dataFlowsData; }
        
        public long getProcessingTimeMs() { return processingTimeMs; }
        public void setProcessingTimeMs(long processingTimeMs) { this.processingTimeMs = processingTimeMs; }
        
        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
    }
}