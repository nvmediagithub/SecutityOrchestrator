package org.example.domain.dto.bpmn;

import jakarta.validation.constraints.NotBlank;
import java.util.List;
import java.util.Map;

/**
 * Request DTO for BPMN analysis regeneration
 * Used for POST /api/analysis/bpmn/{diagramId}/regenerate endpoint
 */
public class BpmnRegenerateRequestDto {
    
    @NotBlank(message = "Diagram ID is required")
    private String diagramId;
    
    private String reason; // Reason for regeneration
    private String triggerSource; // "manual", "scheduled", "api_correction", "manual_override"
    
    private List<RegenerateOption> regenerateOptions;
    private Map<String, Object> regenerateParameters;
    private boolean preservePreviousResults;
    private boolean forceRegenerate;
    private String analysisId; // Previous analysis ID to reference
    private String notificationEndpoint; // Webhook URL for completion notification
    
    public BpmnRegenerateRequestDto() {}
    
    public BpmnRegenerateRequestDto(String diagramId, String reason, String triggerSource,
                                   List<RegenerateOption> regenerateOptions, 
                                   Map<String, Object> regenerateParameters,
                                   boolean preservePreviousResults, boolean forceRegenerate,
                                   String analysisId, String notificationEndpoint) {
        this.diagramId = diagramId;
        this.reason = reason;
        this.triggerSource = triggerSource;
        this.regenerateOptions = regenerateOptions;
        this.regenerateParameters = regenerateParameters;
        this.preservePreviousResults = preservePreviousResults;
        this.forceRegenerate = forceRegenerate;
        this.analysisId = analysisId;
        this.notificationEndpoint = notificationEndpoint;
    }
    
    public enum RegenerateOption {
        STRUCTURE_ANALYSIS,
        SECURITY_ANALYSIS,
        PERFORMANCE_ANALYSIS,
        COMPREHENSIVE_ANALYSIS,
        API_MAPPING,
        COMPLIANCE_CHECK,
        ALL_ANALYSES
    }
    
    // Validation method
    public boolean isValid() {
        return diagramId != null && !diagramId.trim().isEmpty();
    }
    
    // Getters and setters
    public String getDiagramId() { return diagramId; }
    public void setDiagramId(String diagramId) { this.diagramId = diagramId; }
    
    public String getReason() { return reason; }
    public void setReason(String reason) { this.reason = reason; }
    
    public String getTriggerSource() { return triggerSource; }
    public void setTriggerSource(String triggerSource) { this.triggerSource = triggerSource; }
    
    public List<RegenerateOption> getRegenerateOptions() { return regenerateOptions; }
    public void setRegenerateOptions(List<RegenerateOption> regenerateOptions) { this.regenerateOptions = regenerateOptions; }
    
    public Map<String, Object> getRegenerateParameters() { return regenerateParameters; }
    public void setRegenerateParameters(Map<String, Object> regenerateParameters) { this.regenerateParameters = regenerateParameters; }
    
    public boolean isPreservePreviousResults() { return preservePreviousResults; }
    public void setPreservePreviousResults(boolean preservePreviousResults) { this.preservePreviousResults = preservePreviousResults; }
    
    public boolean isForceRegenerate() { return forceRegenerate; }
    public void setForceRegenerate(boolean forceRegenerate) { this.forceRegenerate = forceRegenerate; }
    
    public String getAnalysisId() { return analysisId; }
    public void setAnalysisId(String analysisId) { this.analysisId = analysisId; }
    
    public String getNotificationEndpoint() { return notificationEndpoint; }
    public void setNotificationEndpoint(String notificationEndpoint) { this.notificationEndpoint = notificationEndpoint; }
    
    // Utility methods
    public boolean isManualTrigger() {
        return "manual".equalsIgnoreCase(triggerSource);
    }
    
    public boolean isScheduledTrigger() {
        return "scheduled".equalsIgnoreCase(triggerSource);
    }
    
    public boolean shouldRegenerateAll() {
        return regenerateOptions == null || 
               regenerateOptions.contains(RegenerateOption.ALL_ANALYSES);
    }
}