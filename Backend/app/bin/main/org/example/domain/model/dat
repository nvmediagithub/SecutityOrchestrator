package org.example.domain.model.datamanagement;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Entity representing retention policies for test data
 */
@Entity
@Table(name = "retention_policies")
public class RetentionPolicy {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false, length = 255)
    private String policyId;
    
    @Column(nullable = false, length = 1000)
    private String name;
    
    @Column(length = 2000)
    private String description;
    
    @Column(nullable = false, length = 100)
    private String dataType;
    
    @Column(nullable = false)
    private Integer retentionDays;
    
    @Column(nullable = false)
    private Integer archiveDays;
    
    @Column(length = 50)
    private String deletionPolicy; // IMMEDIATE, GRADUAL, MANUAL, COMPLIANCE_BASED
    
    @Column(length = 100)
    private String scope; // GLOBAL, PROJECT, MODULE, DATASET, VERSION
    
    @Column(length = 255)
    private String appliesToId; // Project ID, Module ID, etc.
    
    @Enumerated(EnumType.STRING)
    private PolicyAction archiveAction = PolicyAction.ARCHIVE_TO_COLD_STORAGE;
    
    @Enumerated(EnumType.STRING)
    private PolicyAction deletionAction = PolicyAction.SECURE_DELETE;
    
    @Column(length = 2000)
    private String conditions; // JSON or SQL conditions
    
    @Column(length = 2000)
    private String exceptions; // Data that should not be deleted
    
    private Boolean isAutomatic = true;
    private Boolean isComplianceRequired = false;
    private Boolean hasGracePeriod = false;
    
    private Integer gracePeriodDays = 0;
    
    @ElementCollection
    private List<String> tags = new ArrayList<>();
    
    @ElementCollection
    private List<String> affectedDataTypes = new ArrayList<>();
    
    @ElementCollection
    private List<String> excludedPatterns = new ArrayList<>();
    
    @ElementCollection
    private Map<String, Object> metadata = new HashMap<>();
    
    private LocalDateTime effectiveFrom;
    private LocalDateTime effectiveTo;
    
    private Boolean isActive = true;
    private Integer priority = 0;
    
    private Integer usageCount = 0;
    private LocalDateTime lastExecuted;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    private String createdBy;
    private String lastModifiedBy;
    private String lastExecutedBy;
    
    @Column(length = 2000)
    private String complianceNotes;
    
    @Column(length = 2000)
    private String auditTrail;
    
    @Column(length = 2000)
    private String notes;
    
    // Constructors
    public RetentionPolicy() {
        this.policyId = "RP_" + System.currentTimeMillis() + "_" + (int)(Math.random() * 10000);
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.tags = new ArrayList<>();
        this.affectedDataTypes = new ArrayList<>();
        this.excludedPatterns = new ArrayList<>();
        this.metadata = new HashMap<>();
    }
    
    public RetentionPolicy(String name, String dataType, Integer retentionDays) {
        this();
        this.name = name;
        this.dataType = dataType;
        this.retentionDays = retentionDays;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getPolicyId() { return policyId; }
    public void setPolicyId(String policyId) { this.policyId = policyId; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public String getDataType() { return dataType; }
    public void setDataType(String dataType) { this.dataType = dataType; }
    
    public Integer getRetentionDays() { return retentionDays; }
    public void setRetentionDays(Integer retentionDays) { this.retentionDays = retentionDays; }
    
    public Integer getArchiveDays() { return archiveDays; }
    public void setArchiveDays(Integer archiveDays) { this.archiveDays = archiveDays; }
    
    public String getDeletionPolicy() { return deletionPolicy; }
    public void setDeletionPolicy(String deletionPolicy) { this.deletionPolicy = deletionPolicy; }
    
    public String getScope() { return scope; }
    public void setScope(String scope) { this.scope = scope; }
    
    public String getAppliesToId() { return appliesToId; }
    public void setAppliesToId(String appliesToId) { this.appliesToId = appliesToId; }
    
    public PolicyAction getArchiveAction() { return archiveAction; }
    public void setArchiveAction(PolicyAction archiveAction) { this.archiveAction = archiveAction; }
    
    public PolicyAction getDeletionAction() { return deletionAction; }
    public void setDeletionAction(PolicyAction deletionAction) { this.deletionAction = deletionAction; }
    
    public String getConditions() { return conditions; }
    public void setConditions(String conditions) { this.conditions = conditions; }
    
    public String getExceptions() { return exceptions; }
    public void setExceptions(String exceptions) { this.exceptions = exceptions; }
    
    public Boolean getIsAutomatic() { return isAutomatic; }
    public void setIsAutomatic(Boolean isAutomatic) { this.isAutomatic = isAutomatic; }
    
    public Boolean getIsComplianceRequired() { return isComplianceRequired; }
    public void setIsComplianceRequired(Boolean isComplianceRequired) { this.isComplianceRequired = isComplianceRequired; }
    
    public Boolean getHasGracePeriod() { return hasGracePeriod; }
    public void setHasGracePeriod(Boolean hasGracePeriod) { this.hasGracePeriod = hasGracePeriod; }
    
    public Integer getGracePeriodDays() { return gracePeriodDays; }
    public void setGracePeriodDays(Integer gracePeriodDays) { this.gracePeriodDays = gracePeriodDays; }
    
    public List<String> getTags() { return tags; }
    public void setTags(List<String> tags) { this.tags = tags; }
    
    public List<String> getAffectedDataTypes() { return affectedDataTypes; }
    public void setAffectedDataTypes(List<String> affectedDataTypes) { this.affectedDataTypes = affectedDataTypes; }
    
    public List<String> getExcludedPatterns() { return excludedPatterns; }
    public void setExcludedPatterns(List<String> excludedPatterns) { this.excludedPatterns = excludedPatterns; }
    
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    
    public LocalDateTime getEffectiveFrom() { return effectiveFrom; }
    public void setEffectiveFrom(LocalDateTime effectiveFrom) { this.effectiveFrom = effectiveFrom; }
    
    public LocalDateTime getEffectiveTo() { return effectiveTo; }
    public void setEffectiveTo(LocalDateTime effectiveTo) { this.effectiveTo = effectiveTo; }
    
    public Boolean getIsActive() { return isActive; }
    public void setIsActive(Boolean isActive) { this.isActive = isActive; }
    
    public Integer getPriority() { return priority; }
    public void setPriority(Integer priority) { this.priority = priority; }
    
    public Integer getUsageCount() { return usageCount; }
    public void setUsageCount(Integer usageCount) { this.usageCount = usageCount; }
    
    public LocalDateTime getLastExecuted() { return lastExecuted; }
    public void setLastExecuted(LocalDateTime lastExecuted) { this.lastExecuted = lastExecuted; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    
    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
    
    public String getLastModifiedBy() { return lastModifiedBy; }
    public void setLastModifiedBy(String lastModifiedBy) { this.lastModifiedBy = lastModifiedBy; }
    
    public String getLastExecutedBy() { return lastExecutedBy; }
    public void setLastExecutedBy(String lastExecutedBy) { this.lastExecutedBy = lastExecutedBy; }
    
    public String getComplianceNotes() { return complianceNotes; }
    public void setComplianceNotes(String complianceNotes) { this.complianceNotes = complianceNotes; }
    
    public String getAuditTrail() { return auditTrail; }
    public void setAuditTrail(String auditTrail) { this.auditTrail = auditTrail; }
    
    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }
    
    // Helper methods
    public boolean isActive() {
        return isActive != null && isActive;
    }
    
    public boolean isInEffect() {
        LocalDateTime now = LocalDateTime.now();
        if (effectiveFrom != null && now.isBefore(effectiveFrom)) {
            return false;
        }
        if (effectiveTo != null && now.isAfter(effectiveTo)) {
            return false;
        }
        return isActive();
    }
    
    public boolean isAutomatic() {
        return isAutomatic != null && isAutomatic;
    }
    
    public boolean isComplianceRequired() {
        return isComplianceRequired != null && isComplianceRequired;
    }
    
    public boolean hasGracePeriod() {
        return hasGracePeriod != null && hasGracePeriod && gracePeriodDays > 0;
    }
    
    public boolean isGlobal() {
        return "GLOBAL".equalsIgnoreCase(scope);
    }
    
    public boolean isProjectSpecific() {
        return "PROJECT".equalsIgnoreCase(scope) && appliesToId != null;
    }
    
    public boolean isModuleSpecific() {
        return "MODULE".equalsIgnoreCase(scope) && appliesToId != null;
    }
    
    public boolean isDataSetSpecific() {
        return "DATASET".equalsIgnoreCase(scope) && appliesToId != null;
    }
    
    public boolean isVersionSpecific() {
        return "VERSION".equalsIgnoreCase(scope) && appliesToId != null;
    }
    
    public boolean shouldArchive() {
        return archiveAction != null && !PolicyAction.DO_NOTHING.equals(archiveAction);
    }
    
    public boolean shouldDelete() {
        return deletionAction != null && !PolicyAction.DO_NOTHING.equals(deletionAction);
    }
    
    public LocalDateTime getArchiveDate(LocalDateTime createdAt) {
        if (createdAt == null || archiveDays == null) return null;
        return createdAt.plusDays(archiveDays);
    }
    
    public LocalDateTime getDeletionDate(LocalDateTime createdAt) {
        if (createdAt == null || retentionDays == null) return null;
        return createdAt.plusDays(retentionDays);
    }
    
    public LocalDateTime getGraceEndDate(LocalDateTime deletionDate) {
        if (deletionDate == null || !hasGracePeriod()) return deletionDate;
        return deletionDate.plusDays(gracePeriodDays);
    }
    
    public void addTag(String tag) {
        if (tag != null && !tags.contains(tag)) {
            tags.add(tag);
        }
    }
    
    public void removeTag(String tag) {
        tags.remove(tag);
    }
    
    public void addAffectedDataType(String dataType) {
        if (dataType != null && !affectedDataTypes.contains(dataType)) {
            affectedDataTypes.add(dataType);
        }
    }
    
    public void removeAffectedDataType(String dataType) {
        affectedDataTypes.remove(dataType);
    }
    
    public void addExcludedPattern(String pattern) {
        if (pattern != null && !excludedPatterns.contains(pattern)) {
            excludedPatterns.add(pattern);
        }
    }
    
    public void removeExcludedPattern(String pattern) {
        excludedPatterns.remove(pattern);
    }
    
    public void addMetadata(String key, Object value) {
        this.metadata.put(key, value);
        this.updatedAt = LocalDateTime.now();
    }
    
    public void setEffectivePeriod(LocalDateTime from, LocalDateTime to) {
        this.effectiveFrom = from;
        this.effectiveTo = to;
        this.updatedAt = LocalDateTime.now();
    }
    
    public void markAsExecuted(String executedBy) {
        this.lastExecuted = LocalDateTime.now();
        this.lastExecutedBy = executedBy;
        this.usageCount++;
        this.updatedAt = LocalDateTime.now();
        
        if (this.auditTrail == null) {
            this.auditTrail = "";
        }
        this.auditTrail += "Executed at " + this.lastExecuted + " by " + executedBy + "\n";
    }
    
    public void activate() {
        this.isActive = true;
        this.updatedAt = LocalDateTime.now();
    }
    
    public void deactivate() {
        this.isActive = false;
        this.updatedAt = LocalDateTime.now();
    }
    
    public void addComplianceNote(String note) {
        this.complianceNotes = (this.complianceNotes != null ? this.complianceNotes + "\n" : "") + note;
    }
    
    // Enums
    public enum PolicyAction {
        DO_NOTHING,
        ARCHIVE_TO_COLD_STORAGE,
        COMPRESS_AND_ARCHIVE,
        ENCRYPT_AND_ARCHIVE,
        MOVE_TO_BACKUP,
        SECURE_DELETE,
        GRADUAL_DELETE,
        ANONYMIZE_AND_KEEP,
        MASK_AND_KEEP
    }
    
    @Override
    public String toString() {
        return "RetentionPolicy{" +
                "policyId='" + policyId + '\'' +
                ", name='" + name + '\'' +
                ", dataType='" + dataType + '\'' +
                ", retentionDays=" + retentionDays +
                ", archiveDays=" + archiveDays +
                ", scope='" + scope + '\'' +
                ", isActive=" + isActive +
                ", isAutomatic=" + isAutomatic +
                '}';
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RetentionPolicy that = (RetentionPolicy) o;
        return Objects.equals(policyId, that.policyId);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(policyId);
    }
}