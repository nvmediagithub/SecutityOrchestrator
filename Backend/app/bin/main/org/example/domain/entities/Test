package org.example.domain.entities;

import org.example.domain.valueobjects.OwaspTestCategory;
import org.example.domain.valueobjects.SeverityLevel;
import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Сущность тестового сценария для OWASP API Security тестирования
 */
@Entity
@Table(name = "test_scenarios")
public class TestScenario {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String scenarioId;
    
    @Column(nullable = false)
    private String name;
    
    @Column(length = 2000)
    private String description;
    
    @Column(length = 1000)
    private String objective;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private OwaspTestCategory category;
    
    @Enumerated(EnumType.STRING)
    private SeverityLevel severity = SeverityLevel.MEDIUM;
    
    @Column(length = 500)
    private String testType; // FUNCTIONAL, SECURITY, PERFORMANCE, INTEGRATION
    
    private String openApiAnalysisId;
    private String bpmnAnalysisId;
    
    private String relatedIssueId;
    private String riskAssessment;
    
    @Column(length = 2000)
    private String preconditions;
    
    @Column(length = 2000)
    private String expectedResults;
    
    @Column(length = 2000)
    private String successCriteria;
    
    @Column(length = 2000)
    private String failureCriteria;
    
    private Integer estimatedDurationMinutes = 30;
    private Integer priority = 3; // 1-5 scale
    
    @ElementCollection
    private List<String> tags = new ArrayList<>();
    
    @ElementCollection
    private List<String> requiredCapabilities = new ArrayList<>();
    
    @ElementCollection
    private List<String> dependencies = new ArrayList<>();
    
    @Column(length = 1000)
    private String environment;
    
    @Column(length = 1000)
    private String testDataSet;
    
    private Boolean isAutomated = false;
    private Boolean isParallelCapable = true;
    private Boolean isRiskBased = false;
    private Boolean isIssueDriven = false;
    
    @Enumerated(EnumType.STRING)
    private TestStatus status = TestStatus.DRAFT;
    
    @Enumerated(EnumType.STRING)
    private TestExecutionType executionType = TestExecutionType.ASYNC;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private LocalDateTime lastExecutedAt;
    
    private String createdBy;
    private String lastModifiedBy;
    
    private Integer executionCount = 0;
    private Integer successCount = 0;
    private Integer failureCount = 0;
    
    @Column(length = 1000)
    private String documentation;
    
    @Column(length = 2000)
    private String notes;
    
    // Constructors
    public TestScenario() {
        this.scenarioId = "TS_" + System.currentTimeMillis() + "_" + (int)(Math.random() * 10000);
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.tags = new ArrayList<>();
        this.requiredCapabilities = new ArrayList<>();
        this.dependencies = new ArrayList<>();
    }
    
    public TestScenario(String name, OwaspTestCategory category) {
        this();
        this.name = name;
        this.category = category;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getScenarioId() { return scenarioId; }
    public void setScenarioId(String scenarioId) { this.scenarioId = scenarioId; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public String getObjective() { return objective; }
    public void setObjective(String objective) { this.objective = objective; }
    
    public OwaspTestCategory getCategory() { return category; }
    public void setCategory(OwaspTestCategory category) { this.category = category; }
    
    public SeverityLevel getSeverity() { return severity; }
    public void setSeverity(SeverityLevel severity) { this.severity = severity; }
    
    public String getTestType() { return testType; }
    public void setTestType(String testType) { this.testType = testType; }
    
    public String getOpenApiAnalysisId() { return openApiAnalysisId; }
    public void setOpenApiAnalysisId(String openApiAnalysisId) { this.openApiAnalysisId = openApiAnalysisId; }
    
    public String getBpmnAnalysisId() { return bpmnAnalysisId; }
    public void setBpmnAnalysisId(String bpmnAnalysisId) { this.bpmnAnalysisId = bpmnAnalysisId; }
    
    public String getRelatedIssueId() { return relatedIssueId; }
    public void setRelatedIssueId(String relatedIssueId) { this.relatedIssueId = relatedIssueId; }
    
    public String getRiskAssessment() { return riskAssessment; }
    public void setRiskAssessment(String riskAssessment) { this.riskAssessment = riskAssessment; }
    
    public String getPreconditions() { return preconditions; }
    public void setPreconditions(String preconditions) { this.preconditions = preconditions; }
    
    public String getExpectedResults() { return expectedResults; }
    public void setExpectedResults(String expectedResults) { this.expectedResults = expectedResults; }
    
    public String getSuccessCriteria() { return successCriteria; }
    public void setSuccessCriteria(String successCriteria) { this.successCriteria = successCriteria; }
    
    public String getFailureCriteria() { return failureCriteria; }
    public void setFailureCriteria(String failureCriteria) { this.failureCriteria = failureCriteria; }
    
    public Integer getEstimatedDurationMinutes() { return estimatedDurationMinutes; }
    public void setEstimatedDurationMinutes(Integer estimatedDurationMinutes) { this.estimatedDurationMinutes = estimatedDurationMinutes; }
    
    public Integer getPriority() { return priority; }
    public void setPriority(Integer priority) { this.priority = priority; }
    
    public List<String> getTags() { return tags; }
    public void setTags(List<String> tags) { this.tags = tags; }
    
    public List<String> getRequiredCapabilities() { return requiredCapabilities; }
    public void setRequiredCapabilities(List<String> requiredCapabilities) { this.requiredCapabilities = requiredCapabilities; }
    
    public List<String> getDependencies() { return dependencies; }
    public void setDependencies(List<String> dependencies) { this.dependencies = dependencies; }
    
    public String getEnvironment() { return environment; }
    public void setEnvironment(String environment) { this.environment = environment; }
    
    public String getTestDataSet() { return testDataSet; }
    public void setTestDataSet(String testDataSet) { this.testDataSet = testDataSet; }
    
    public Boolean getIsAutomated() { return isAutomated; }
    public void setIsAutomated(Boolean isAutomated) { this.isAutomated = isAutomated; }
    
    public Boolean getIsParallelCapable() { return isParallelCapable; }
    public void setIsParallelCapable(Boolean isParallelCapable) { this.isParallelCapable = isParallelCapable; }
    
    public Boolean getIsRiskBased() { return isRiskBased; }
    public void setIsRiskBased(Boolean isRiskBased) { this.isRiskBased = isRiskBased; }
    
    public Boolean getIsIssueDriven() { return isIssueDriven; }
    public void setIsIssueDriven(Boolean isIssueDriven) { this.isIssueDriven = isIssueDriven; }
    
    public TestStatus getStatus() { return status; }
    public void setStatus(TestStatus status) { this.status = status; }
    
    public TestExecutionType getExecutionType() { return executionType; }
    public void setExecutionType(TestExecutionType executionType) { this.executionType = executionType; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    
    public LocalDateTime getLastExecutedAt() { return lastExecutedAt; }
    public void setLastExecutedAt(LocalDateTime lastExecutedAt) { this.lastExecutedAt = lastExecutedAt; }
    
    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
    
    public String getLastModifiedBy() { return lastModifiedBy; }
    public void setLastModifiedBy(String lastModifiedBy) { this.lastModifiedBy = lastModifiedBy; }
    
    public Integer getExecutionCount() { return executionCount; }
    public void setExecutionCount(Integer executionCount) { this.executionCount = executionCount; }
    
    public Integer getSuccessCount() { return successCount; }
    public void setSuccessCount(Integer successCount) { this.successCount = successCount; }
    
    public Integer getFailureCount() { return failureCount; }
    public void setFailureCount(Integer failureCount) { this.failureCount = failureCount; }
    
    public String getDocumentation() { return documentation; }
    public void setDocumentation(String documentation) { this.documentation = documentation; }
    
    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }
    
    // Helper methods
    public double getSuccessRate() {
        if (executionCount == 0) return 0.0;
        return (double) successCount / executionCount * 100.0;
    }
    
    public boolean isSecurityTest() {
        return testType != null && testType.toUpperCase().contains("SECURITY");
    }
    
    public boolean isPerformanceTest() {
        return testType != null && testType.toUpperCase().contains("PERFORMANCE");
    }
    
    public boolean isFunctionalTest() {
        return testType != null && testType.toUpperCase().contains("FUNCTIONAL");
    }
    
    public void addTag(String tag) {
        if (tag != null && !tags.contains(tag)) {
            tags.add(tag);
        }
    }
    
    public void addRequiredCapability(String capability) {
        if (capability != null && !requiredCapabilities.contains(capability)) {
            requiredCapabilities.add(capability);
        }
    }
    
    public void addDependency(String dependency) {
        if (dependency != null && !dependencies.contains(dependency)) {
            dependencies.add(dependency);
        }
    }
    
    public void incrementExecutionCount() {
        this.executionCount++;
        this.updatedAt = LocalDateTime.now();
    }
    
    public void recordSuccess() {
        this.successCount++;
        this.lastExecutedAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    public void recordFailure() {
        this.failureCount++;
        this.lastExecutedAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    public void markAsReviewed() {
        this.status = TestStatus.REVIEWED;
        this.updatedAt = LocalDateTime.now();
    }
    
    public void markAsApproved() {
        this.status = TestStatus.APPROVED;
        this.updatedAt = LocalDateTime.now();
    }
    
    public void markAsDeprecated() {
        this.status = TestStatus.DEPRECATED;
        this.updatedAt = LocalDateTime.now();
    }
    
    public boolean isExecutable() {
        return status == TestStatus.APPROVED || status == TestStatus.READY;
    }
    
    public boolean isActive() {
        return status != TestStatus.DEPRECATED && status != TestStatus.DRAFT;
    }
    
    @Override
    public String toString() {
        return "TestScenario{" +
                "scenarioId='" + scenarioId + '\'' +
                ", name='" + name + '\'' +
                ", category=" + category +
                ", severity=" + severity +
                ", testType='" + testType + '\'' +
                ", status=" + status +
                '}';
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TestScenario that = (TestScenario) o;
        return Objects.equals(scenarioId, that.scenarioId);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(scenarioId);
    }
    
    // Enums
    public enum TestStatus {
        DRAFT,
        REVIEWED,
        APPROVED,
        READY,
        IN_PROGRESS,
        EXECUTED,
        FAILED,
        PASSED,
        DEPRECATED
    }
    
    public enum TestExecutionType {
        SYNC,
        ASYNC,
        SCHEDULED,
        CONTINUOUS
    }
}