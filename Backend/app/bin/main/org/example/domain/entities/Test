package org.example.domain.entities;

import org.example.domain.valueobjects.SeverityLevel;
import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Шаг выполнения теста - представляет отдельный этап в сквозном тестировании
 * Может быть OWASP тестом, API тестом, BPMN процессом или анализом
 */
@Entity
@Table(name = "test_execution_steps")
public class TestExecutionStep {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String stepId;
    
    @Column(nullable = false)
    private String sessionId; // Связь с TestExecutionSession
    
    @Column(length = 1000, nullable = false)
    private String stepName;
    
    @Column(length = 2000)
    private String description;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StepType stepType;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StepStatus status = StepStatus.PENDING;
    
    @Enumerated(EnumType.STRING)
    private SeverityLevel severity = SeverityLevel.INFO;
    
    private Integer stepOrder = 0;
    
    @Column(length = 2000)
    private String targetComponent; // OpenAPI service, BPMN process, OWASP category
    
    @Column(length = 2000)
    private String testType; // SECURITY, FUNCTIONAL, PERFORMANCE, INTEGRATION
    
    private LocalDateTime startedAt;
    private LocalDateTime completedAt;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    private Long durationMs;
    private Long preparationTimeMs;
    private Long executionTimeMs;
    private Long validationTimeMs;
    
    @Column(length = 4000)
    private String inputData;
    
    @Column(length = 4000)
    private String outputData;
    
    @Column(length = 4000)
    private String expectedResult;
    
    @Column(length = 4000)
    private String actualResult;
    
    @Enumerated(EnumType.STRING)
    private ComparisonResult comparisonResult = ComparisonResult.NOT_COMPARED;
    
    @Column(length = 4000)
    private String errorDetails;
    
    @Column(length = 2000)
    private String errorCode;
    
    @Column(length = 2000)
    private String errorType; // TIMEOUT, ASSERTION_ERROR, NETWORK_ERROR, CONTRACT_VIOLATION
    
    @Column(length = 2000)
    private String failureReason;
    
    @Column(length = 2000)
    private String executor; // Пользователь или система
    
    @Column(length = 2000)
    private String environment;
    
    @ElementCollection
    private List<String> assertions = new ArrayList<>();
    
    @ElementCollection
    private List<String> failedAssertions = new ArrayList<>();
    
    @ElementCollection
    private List<String> warnings = new ArrayList<>();
    
    @ElementCollection
    private List<String> generatedArtifacts = new ArrayList<>();
    
    @ElementCollection
    private List<String> capturedLogs = new ArrayList<>();
    
    @ElementCollection
    private List<String> networkRequests = new ArrayList<>();
    
    @ElementCollection
    private List<String> securityChecks = new ArrayList<>();
    
    @ElementCollection
    private Map<String, String> metrics = new HashMap<>();
    
    @ElementCollection
    private Map<String, String> performanceData = new HashMap<>();
    
    @ElementCollection
    private List<String> dependencies = new ArrayList<>();
    
    private Boolean isParallelExecution = false;
    private String parallelExecutionId;
    private Integer parallelExecutionIndex;
    
    private Boolean isCritical = false;
    private Boolean isRetryable = false;
    
    private Integer retryCount = 0;
    private Integer maxRetries = 3;
    private String retryReason;
    
    @Column(length = 2000)
    private String testDataSetUsed;
    
    @Column(length = 4000)
    private String configuration;
    
    @Column(length = 2000)
    private String resourceUsage; // CPU, Memory, Disk usage
    
    @Column(length = 4000)
    private String systemInformation;
    
    @Column(length = 4000)
    private String llmAnalysisResult;
    
    private Boolean requiresManualReview = false;
    private Boolean isKnownIssue = false;
    
    @Column(length = 2000)
    private String knownIssueId;
    
    @Column(length = 4000)
    private String notes;
    
    @Column(length = 2000)
    private String relatedStepId;
    
    private String parentStepId;
    
    // Конструкторы
    public TestExecutionStep() {
        this.stepId = "STEP_" + System.currentTimeMillis() + "_" + (int)(Math.random() * 10000);
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.assertions = new ArrayList<>();
        this.failedAssertions = new ArrayList<>();
        this.warnings = new ArrayList<>();
        this.generatedArtifacts = new ArrayList<>();
        this.capturedLogs = new ArrayList<>();
        this.networkRequests = new ArrayList<>();
        this.securityChecks = new ArrayList<>();
        this.metrics = new HashMap<>();
        this.performanceData = new HashMap<>();
        this.dependencies = new ArrayList<>();
    }
    
    public TestExecutionStep(String sessionId, String stepName, StepType stepType) {
        this();
        this.sessionId = sessionId;
        this.stepName = stepName;
        this.stepType = stepType;
    }
    
    // Вспомогательные методы
    public boolean isCompleted() {
        return status == StepStatus.PASSED || status == StepStatus.FAILED || 
               status == StepStatus.SKIPPED || status == StepStatus.ERROR ||
               status == StepStatus.TIMEOUT || status == StepStatus.CANCELLED;
    }
    
    public boolean isSuccess() {
        return status == StepStatus.PASSED;
    }
    
    public boolean isFailure() {
        return status == StepStatus.FAILED || status == StepStatus.ERROR;
    }
    
    public boolean hasWarnings() {
        return !warnings.isEmpty();
    }
    
    public boolean hasFailedAssertions() {
        return !failedAssertions.isEmpty();
    }
    
    public boolean canRetry() {
        return retryCount < maxRetries && isRetryable && 
               (status == StepStatus.ERROR || status == StepStatus.TIMEOUT ||
                (status == StepStatus.FAILED && hasFailedAssertions()));
    }
    
    public void start() {
        this.status = StepStatus.IN_PROGRESS;
        this.startedAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        addLog("Step started: " + stepName);
    }
    
    public void complete(boolean success) {
        this.completedAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        
        if (success) {
            this.status = StepStatus.PASSED;
            this.severity = SeverityLevel.INFO;
        } else {
            this.status = StepStatus.FAILED;
            this.severity = hasFailedAssertions() ? SeverityLevel.HIGH : SeverityLevel.MEDIUM;
        }
        
        if (this.startedAt != null && this.completedAt != null) {
            this.durationMs = java.time.Duration.between(this.startedAt, this.completedAt).toMillis();
        }
        
        addLog("Step completed: " + stepName + " - " + (success ? "PASSED" : "FAILED"));
    }
    
    public void recordError(String errorMessage, String errorType) {
        this.status = StepStatus.ERROR;
        this.errorDetails = errorMessage;
        this.errorType = errorType;
        this.completedAt = LocalDateTime.now();
        this.durationMs = startedAt != null ? 
            java.time.Duration.between(startedAt, completedAt).toMillis() : 0L;
        this.severity = SeverityLevel.CRITICAL;
        addLog("Error recorded: " + errorMessage);
    }
    
    public void recordTimeout(String timeoutMessage) {
        this.status = StepStatus.TIMEOUT;
        this.errorDetails = timeoutMessage;
        this.errorType = "TIMEOUT";
        this.completedAt = LocalDateTime.now();
        this.durationMs = startedAt != null ? 
            java.time.Duration.between(startedAt, completedAt).toMillis() : 0L;
        this.severity = SeverityLevel.HIGH;
        addLog("Timeout occurred: " + timeoutMessage);
    }
    
    public void recordContractViolation(String violationDetails) {
        this.status = StepStatus.FAILED;
        this.errorDetails = violationDetails;
        this.errorType = "CONTRACT_VIOLATION";
        this.comparisonResult = ComparisonResult.MISMATCH;
        this.severity = SeverityLevel.HIGH;
        addLog("Contract violation detected: " + violationDetails);
    }
    
    public void recordUnexpectedData(String dataDetails) {
        this.status = StepStatus.FAILED;
        this.errorDetails = "Unexpected data: " + dataDetails;
        this.errorType = "UNEXPECTED_DATA";
        this.comparisonResult = ComparisonResult.MISMATCH;
        this.severity = SeverityLevel.MEDIUM;
        addLog("Unexpected data detected: " + dataDetails);
    }
    
    public void addAssertion(String assertionId) {
        if (assertionId != null && !assertions.contains(assertionId)) {
            assertions.add(assertionId);
            addLog("Assertion added: " + assertionId);
        }
    }
    
    public void addFailedAssertion(String assertionId) {
        if (assertionId != null && !failedAssertions.contains(assertionId)) {
            failedAssertions.add(assertionId);
            this.severity = SeverityLevel.HIGH;
            addLog("Failed assertion: " + assertionId);
        }
    }
    
    public void addWarning(String warning) {
        if (warning != null && !warnings.contains(warning)) {
            warnings.add(warning);
            addLog("Warning: " + warning);
        }
    }
    
    public void addMetric(String key, String value) {
        if (key != null && value != null) {
            metrics.put(key, value);
        }
    }
    
    public void addPerformanceData(String key, String value) {
        if (key != null && value != null) {
            performanceData.put(key, value);
        }
    }
    
    public void addSecurityCheck(String check, String result) {
        if (check != null && result != null) {
            securityChecks.put(check, result);
            if ("FAILED".equals(result) || "VIOLATION".equals(result)) {
                this.severity = SeverityLevel.HIGH;
            }
        }
    }
    
    public void addLog(String logEntry) {
        if (logEntry != null) {
            String timestamp = LocalDateTime.now().toString();
            capturedLogs.add("[" + timestamp + "] " + logEntry);
        }
    }
    
    public void addArtifact(String artifact) {
        if (artifact != null && !generatedArtifacts.contains(artifact)) {
            generatedArtifacts.add(artifact);
        }
    }
    
    public void addNetworkRequest(String request) {
        if (request != null && !networkRequests.contains(request)) {
            networkRequests.add(request);
        }
    }
    
    public void recordTiming(String phase, long durationMs) {
        switch (phase.toLowerCase()) {
            case "preparation":
                this.preparationTimeMs = durationMs;
                break;
            case "execution":
                this.executionTimeMs = durationMs;
                break;
            case "validation":
                this.validationTimeMs = durationMs;
                break;
        }
    }
    
    public void retry(String reason) {
        this.retryCount++;
        this.isRetryable = true;
        this.retryReason = reason;
        this.status = StepStatus.PENDING;
        this.startedAt = null;
        this.completedAt = null;
        this.durationMs = null;
        this.errorDetails = null;
        addLog("Step retried due to: " + reason);
    }
    
    public void skip(String reason) {
        this.status = StepStatus.SKIPPED;
        this.completedAt = LocalDateTime.now();
        this.failureReason = "Skipped: " + reason;
        addLog("Step skipped: " + reason);
    }
    
    // Enums
    public enum StepType {
        OPENAPI_TEST,
        BPMN_PROCESS_TEST,
        OWASP_SECURITY_TEST,
        LLM_ANALYSIS,
        TEST_DATA_GENERATION,
        INTEGRATION_TEST,
        PERFORMANCE_TEST,
        CONTRACT_VALIDATION,
        DATA_VALIDATION,
        SYSTEM_CHECK
    }
    
    public enum StepStatus {
        PENDING,
        PREPARING,
        IN_PROGRESS,
        PASSED,
        FAILED,
        ERROR,
        SKIPPED,
        TIMEOUT,
        CANCELLED
    }
    
    public enum ComparisonResult {
        NOT_COMPARED,
        MATCH,
        MISMATCH,
        PARTIAL_MATCH,
        CONTRACT_VIOLATION
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getStepId() { return stepId; }
    public void setStepId(String stepId) { this.stepId = stepId; }
    
    public String getSessionId() { return sessionId; }
    public void setSessionId(String sessionId) { this.sessionId = sessionId; }
    
    public String getStepName() { return stepName; }
    public void setStepName(String stepName) { this.stepName = stepName; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public StepType getStepType() { return stepType; }
    public void setStepType(StepType stepType) { this.stepType = stepType; }
    
    public StepStatus getStatus() { return status; }
    public void setStatus(StepStatus status) { this.status = status; }
    
    public SeverityLevel getSeverity() { return severity; }
    public void setSeverity(SeverityLevel severity) { this.severity = severity; }
    
    public Integer getStepOrder() { return stepOrder; }
    public void setStepOrder(Integer stepOrder) { this.stepOrder = stepOrder; }
    
    public String getTargetComponent() { return targetComponent; }
    public void setTargetComponent(String targetComponent) { this.targetComponent = targetComponent; }
    
    public String getTestType() { return testType; }
    public void setTestType(String testType) { this.testType = testType; }
    
    public LocalDateTime getStartedAt() { return startedAt; }
    public void setStartedAt(LocalDateTime startedAt) { this.startedAt = startedAt; }
    
    public LocalDateTime getCompletedAt() { return completedAt; }
    public void setCompletedAt(LocalDateTime completedAt) { this.completedAt = completedAt; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    
    public Long getDurationMs() { return durationMs; }
    public void setDurationMs(Long durationMs) { this.durationMs = durationMs; }
    
    public Long getPreparationTimeMs() { return preparationTimeMs; }
    public void setPreparationTimeMs(Long preparationTimeMs) { this.preparationTimeMs = preparationTimeMs; }
    
    public Long getExecutionTimeMs() { return executionTimeMs; }
    public void setExecutionTimeMs(Long executionTimeMs) { this.executionTimeMs = executionTimeMs; }
    
    public Long getValidationTimeMs() { return validationTimeMs; }
    public void setValidationTimeMs(Long validationTimeMs) { this.validationTimeMs = validationTimeMs; }
    
    public String getInputData() { return inputData; }
    public void setInputData(String inputData) { this.inputData = inputData; }
    
    public String getOutputData() { return outputData; }
    public void setOutputData(String outputData) { this.outputData = outputData; }
    
    public String getExpectedResult() { return expectedResult; }
    public void setExpectedResult(String expectedResult) { this.expectedResult = expectedResult; }
    
    public String getActualResult() { return actualResult; }
    public void setActualResult(String actualResult) { this.actualResult = actualResult; }
    
    public ComparisonResult getComparisonResult() { return comparisonResult; }
    public void setComparisonResult(ComparisonResult comparisonResult) { this.comparisonResult = comparisonResult; }
    
    public String getErrorDetails() { return errorDetails; }
    public void setErrorDetails(String errorDetails) { this.errorDetails = errorDetails; }
    
    public String getErrorCode() { return errorCode; }
    public void setErrorCode(String errorCode) { this.errorCode = errorCode; }
    
    public String getErrorType() { return errorType; }
    public void setErrorType(String errorType) { this.errorType = errorType; }
    
    public String getFailureReason() { return failureReason; }
    public void setFailureReason(String failureReason) { this.failureReason = failureReason; }
    
    public String getExecutor() { return executor; }
    public void setExecutor(String executor) { this.executor = executor; }
    
    public String getEnvironment() { return environment; }
    public void setEnvironment(String environment) { this.environment = environment; }
    
    public List<String> getAssertions() { return assertions; }
    public void setAssertions(List<String> assertions) { this.assertions = assertions; }
    
    public List<String> getFailedAssertions() { return failedAssertions; }
    public void setFailedAssertions(List<String> failedAssertions) { this.failedAssertions = failedAssertions; }
    
    public List<String> getWarnings() { return warnings; }
    public void setWarnings(List<String> warnings) { this.warnings = warnings; }
    
    public List<String> getGeneratedArtifacts() { return generatedArtifacts; }
    public void setGeneratedArtifacts(List<String> generatedArtifacts) { this.generatedArtifacts = generatedArtifacts; }
    
    public List<String> getCapturedLogs() { return capturedLogs; }
    public void setCapturedLogs(List<String> capturedLogs) { this.capturedLogs = capturedLogs; }
    
    public List<String> getNetworkRequests() { return networkRequests; }
    public void setNetworkRequests(List<String> networkRequests) { this.networkRequests = networkRequests; }
    
    public List<String> getSecurityChecks() { return securityChecks; }
    public void setSecurityChecks(List<String> securityChecks) { this.securityChecks = securityChecks; }
    
    public Map<String, String> getMetrics() { return metrics; }
    public void setMetrics(Map<String, String> metrics) { this.metrics = metrics; }
    
    public Map<String, String> getPerformanceData() { return performanceData; }
    public void setPerformanceData(Map<String, String> performanceData) { this.performanceData = performanceData; }
    
    public List<String> getDependencies() { return dependencies; }
    public void setDependencies(List<String> dependencies) { this.dependencies = dependencies; }
    
    public Boolean getIsParallelExecution() { return isParallelExecution; }
    public void setIsParallelExecution(Boolean isParallelExecution) { this.isParallelExecution = isParallelExecution; }
    
    public String getParallelExecutionId() { return parallelExecutionId; }
    public void setParallelExecutionId(String parallelExecutionId) { this.parallelExecutionId = parallelExecutionId; }
    
    public Integer getParallelExecutionIndex() { return parallelExecutionIndex; }
    public void setParallelExecutionIndex(Integer parallelExecutionIndex) { this.parallelExecutionIndex = parallelExecutionIndex; }
    
    public Boolean getIsCritical() { return isCritical; }
    public void setIsCritical(Boolean isCritical) { this.isCritical = isCritical; }
    
    public Boolean getIsRetryable() { return isRetryable; }
    public void setIsRetryable(Boolean isRetryable) { this.isRetryable = isRetryable; }
    
    public Integer getRetryCount() { return retryCount; }
    public void setRetryCount(Integer retryCount) { this.retryCount = retryCount; }
    
    public Integer getMaxRetries() { return maxRetries; }
    public void setMaxRetries(Integer maxRetries) { this.maxRetries = maxRetries; }
    
    public String getRetryReason() { return retryReason; }
    public void setRetryReason(String retryReason) { this.retryReason = retryReason; }
    
    public String getTestDataSetUsed() { return testDataSetUsed; }
    public void setTestDataSetUsed(String testDataSetUsed) { this.testDataSetUsed = testDataSetUsed; }
    
    public String getConfiguration() { return configuration; }
    public void setConfiguration(String configuration) { this.configuration = configuration; }
    
    public String getResourceUsage() { return resourceUsage; }
    public void setResourceUsage(String resourceUsage) { this.resourceUsage = resourceUsage; }
    
    public String getSystemInformation() { return systemInformation; }
    public void setSystemInformation(String systemInformation) { this.systemInformation = systemInformation; }
    
    public String getLlmAnalysisResult() { return llmAnalysisResult; }
    public void setLlmAnalysisResult(String llmAnalysisResult) { this.llmAnalysisResult = llmAnalysisResult; }
    
    public Boolean getRequiresManualReview() { return requiresManualReview; }
    public void setRequiresManualReview(Boolean requiresManualReview) { this.requiresManualReview = requiresManualReview; }
    
    public Boolean getIsKnownIssue() { return isKnownIssue; }
    public void setIsKnownIssue(Boolean isKnownIssue) { this.isKnownIssue = isKnownIssue; }
    
    public String getKnownIssueId() { return knownIssueId; }
    public void setKnownIssueId(String knownIssueId) { this.knownIssueId = knownIssueId; }
    
    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }
    
    public String getRelatedStepId() { return relatedStepId; }
    public void setRelatedStepId(String relatedStepId) { this.relatedStepId = relatedStepId; }
    
    public String getParentStepId() { return parentStepId; }
    public void setParentStepId(String parentStepId) { this.parentStepId = parentStepId; }
    
    @Override
    public String toString() {
        return "TestExecutionStep{" +
                "stepId='" + stepId + '\'' +
                ", stepName='" + stepName + '\'' +
                ", stepType=" + stepType +
                ", status=" + status +
                ", severity=" + severity +
                ", durationMs=" + durationMs +
                '}';
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TestExecutionStep that = (TestExecutionStep) o;
        return Objects.equals(stepId, that.stepId);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(stepId);
    }
}