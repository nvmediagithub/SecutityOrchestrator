package org.example.application.service.e2e;

import org.example.domain.entities.*;
import org.example.domain.valueobjects.OwaspTestCategory;
import org.example.application.service.openapi.OpenApiParsingService;
import org.example.application.service.bpmn.BpmnParsingService;
import org.example.infrastructure.services.owasp.OwaspTestGenerationService;
import org.example.application.service.testdata.TestDataGenerationService;
import org.example.domain.dto.testdata.GenerationRequest;
import org.example.domain.dto.testdata.GenerationResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.scheduling.annotation.Async;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

/**
 * Основной сервис для выполнения сквозного тестирования
 * Координирует выполнение OpenAPI, BPMN, OWASP тестов и интегрирует с LLM анализом
 */
@Service
@Transactional
public class EndToEndTestExecutionService {
    
    private static final Logger logger = LoggerFactory.getLogger(EndToEndTestExecutionService.class);
    
    @Autowired
    private OpenApiParsingService openApiParsingService;
    
    @Autowired
    private BpmnParsingService bpmnParsingService;
    
    @Autowired
    private OwaspTestGenerationService owaspTestGenerationService;
    
    @Autowired
    private TestDataGenerationService testDataGenerationService;
    
    @Autowired
    private TestExecutionEngine testExecutionEngine;
    
    @Autowired
    private LLMAnalysisService llmAnalysisService;
    
    @Autowired
    private ExecutionMonitoringService executionMonitoringService;
    
    private final ExecutorService executionExecutor = Executors.newFixedThreadPool(10);
    private final Map<String, TestExecutionSession> activeSessions = new ConcurrentHashMap<>();
    private final Map<String, CompletableFuture<TestExecutionSession>> runningSessions = new ConcurrentHashMap<>();
    
    /**
     * Запуск сквозного тестирования системы
     */
    public CompletableFuture<TestExecutionSession> startEndToEndSession(TestExecutionRequest request) {
        logger.info("Starting end-to-end test session: {}", request.getSessionName());
        
        // Создаем сессию выполнения
        TestExecutionSession session = createExecutionSession(request);
        activeSessions.put(session.getSessionId(), session);
        
        // Запускаем асинхронное выполнение
        CompletableFuture<TestExecutionSession> executionFuture = CompletableFuture
                .supplyAsync(() -> executeEndToEndTests(session, request), executionExecutor)
                .thenCompose(this::analyzeResultsWithLLM)
                .thenApply(this::finalizeSession)
                .whenComplete((result, error) -> {
                    activeSessions.remove(session.getSessionId());
                    runningSessions.remove(session.getSessionId());
                });
        
        runningSessions.put(session.getSessionId(), executionFuture);
        
        // Уведомляем о начале сессии
        executionMonitoringService.notifySessionStarted(session);
        
        return executionFuture;
    }
    
    /**
     * Получение статуса сессии выполнения
     */
    public Optional<TestExecutionSession> getSessionStatus(String sessionId) {
        return Optional.ofNullable(activeSessions.get(sessionId));
    }
    
    /**
     * Получение всех активных сессий
     */
    public List<TestExecutionSession> getActiveSessions() {
        return new ArrayList<>(activeSessions.values());
    }
    
    /**
     * Отмена выполнения сессии
     */
    public CompletableFuture<Void> cancelSession(String sessionId) {
        logger.info("Cancelling test session: {}", sessionId);
        
        CompletableFuture<TestExecutionSession> runningSession = runningSessions.get(sessionId);
        if (runningSession != null) {
            runningSession.cancel(true);
        }
        
        TestExecutionSession session = activeSessions.get(sessionId);
        if (session != null) {
            session.setStatus(TestExecutionSession.SessionStatus.CANCELLED);
            executionMonitoringService.notifySessionCancelled(session);
        }
        
        return CompletableFuture.completedFuture(null);
    }
    
    /**
     * Повторный запуск неуспешной сессии
     */
    public CompletableFuture<TestExecutionSession> retrySession(String sessionId) {
        logger.info("Retrying test session: {}", sessionId);
        
        TestExecutionSession originalSession = activeSessions.get(sessionId);
        if (originalSession == null || !originalSession.canRetry()) {
            throw new IllegalArgumentException("Session cannot be retried or does not exist");
        }
        
        // Создаем новую сессию для повтора
        TestExecutionRequest retryRequest = createRetryRequest(originalSession);
        return startEndToEndSession(retryRequest);
    }
    
    /**
     * Получение детальной информации о сессии
     */
    public TestExecutionSessionDetails getSessionDetails(String sessionId) {
        TestExecutionSession session = activeSessions.get(sessionId);
        if (session == null) {
            return null;
        }
        
        return TestExecutionSessionDetails.builder()
                .session(session)
                .steps(testExecutionEngine.getStepsForSession(sessionId))
                .results(testExecutionEngine.getResultsForSession(sessionId))
                .errors(executionMonitoringService.getErrorsForSession(sessionId))
                .metrics(executionMonitoringService.getMetricsForSession(sessionId))
                .llmAnalysis(llmAnalysisService.getAnalysisForSession(sessionId))
                .build();
    }
    
    /**
     * Создание плана выполнения тестов
     */
    public TestExecutionPlan createExecutionPlan(TestExecutionRequest request) {
        logger.info("Creating execution plan for: {}", request.getSessionName());
        
        TestExecutionPlan.Builder planBuilder = TestExecutionPlan.builder()
                .sessionName(request.getSessionName())
                .description(request.getDescription());
        
        // Добавляем этапы в зависимости от запроса
        if (request.getOpenApiServiceId() != null) {
            planBuilder.addStep(createOpenApiTestStep(request));
        }
        
        if (request.getBpmnProcessId() != null) {
            planBuilder.addStep(createBpmnTestStep(request));
        }
        
        if (request.getOwaspCategories() != null && !request.getOwaspCategories().isEmpty()) {
            planBuilder.addStep(createOwaspTestStep(request));
        }
        
        if (request.getTestDataContextId() != null) {
            planBuilder.addStep(createDataGenerationStep(request));
        }
        
        // Добавляем LLM анализ
        planBuilder.addStep(createLLMAnalysisStep(request));
        
        return planBuilder.build();
    }
    
    // Приватные методы
    
    private TestExecutionSession createExecutionSession(TestExecutionRequest request) {
        TestExecutionSession session = new TestExecutionSession(request.getSessionName(), request.getInitiatedBy());
        session.setDescription(request.getDescription());
        session.setOpenApiServiceId(request.getOpenApiServiceId());
        session.setBpmnProcessId(request.getBpmnProcessId());
        session.setTestDataContextId(request.getTestDataContextId());
        session.setOwaspTestCategories(request.getOwaspCategories());
        session.setExecutionConfig(request.getConfiguration());
        session.setEnvironment(request.getEnvironment());
        session.setIsAutomatedExecution(request.getIsAutomatedExecution());
        session.setIsParallelExecution(request.getIsParallelExecution());
        session.setIsDebugMode(request.getIsDebugMode());
        
        return session;
    }
    
    private TestExecutionSession executeEndToEndTests(TestExecutionSession session, TestExecutionRequest request) {
        try {
            logger.info("Starting execution of end-to-end tests for session: {}", session.getSessionId());
            session.startSession();
            executionMonitoringService.notifySessionStatusUpdate(session);
            
            // Этап 1: Подготовка и генерация тестовых данных
            executePreparationPhase(session, request);
            
            // Этап 2: Выполнение OpenAPI тестов
            if (request.getOpenApiServiceId() != null) {
                executeOpenApiTests(session, request);
            }
            
            // Этап 3: Выполнение BPMN тестов
            if (request.getBpmnProcessId() != null) {
                executeBpmnTests(session, request);
            }
            
            // Этап 4: Выполнение OWASP тестов безопасности
            if (request.getOwaspCategories() != null && !request.getOwaspCategories().isEmpty()) {
                executeOwaspTests(session, request);
            }
            
            // Этап 5: Выполнение интеграционных тестов
            executeIntegrationTests(session, request);
            
            // Завершаем сессию
            boolean success = session.getFailedSteps() == 0;
            session.completeSession(success);
            
            logger.info("End-to-end test execution completed for session: {}. Success: {}", 
                       session.getSessionId(), success);
            
            return session;
            
        } catch (Exception e) {
            logger.error("Error during end-to-end test execution for session: {}", session.getSessionId(), e);
            session.setStatus(TestExecutionSession.SessionStatus.ERROR);
            session.addError("Execution failed: " + e.getMessage());
            executionMonitoringService.notifySessionError(session, e);
            return session;
        }
    }
    
    private void executePreparationPhase(TestExecutionSession session, TestExecutionRequest request) {
        logger.info("Executing preparation phase for session: {}", session.getSessionId());
        session.addStep("Preparation Phase");
        
        try {
            // Генерация тестовых данных если требуется
            if (request.getTestDataContextId() != null) {
                GenerationRequest genRequest = new GenerationRequest();
                genRequest.setContextId(request.getTestDataContextId());
                genRequest.setScope(GenerationRequest.GenerationScope.COMPREHENSIVE);
                
                CompletableFuture<GenerationResponse> dataGeneration = 
                        testDataGenerationService.generateIntelligentData(genRequest);
                
                GenerationResponse response = dataGeneration.join();
                session.addArtifact("Test data generated: " + response.getGeneratedDatasets().size() + " datasets");
            }
            
            session.completeStep("Preparation Phase", true);
            executionMonitoringService.notifyStepCompleted(session, "Preparation Phase", true);
            
        } catch (Exception e) {
            logger.error("Error in preparation phase", e);
            session.completeStep("Preparation Phase", false);
            session.addError("Preparation failed: " + e.getMessage());
            executionMonitoringService.notifyStepCompleted(session, "Preparation Phase", false);
        }
    }
    
    private void executeOpenApiTests(TestExecutionSession session, TestExecutionRequest request) {
        logger.info("Executing OpenAPI tests for session: {}", session.getSessionId());
        session.addStep("OpenAPI Tests");
        
        try {
            TestExecutionStep step = new TestExecutionStep(
                    session.getSessionId(), 
                    "OpenAPI Test Execution", 
                    TestExecutionStep.StepType.OPENAPI_TEST
            );
            
            step.setTargetComponent(request.getOpenApiServiceId());
            step.setTestType("API_VALIDATION");
            step.start();
            
            // Выполняем тесты через движок выполнения
            CompletableFuture<ExecutionResult> testExecution = 
                    testExecutionEngine.executeOpenApiTests(request.getOpenApiServiceId(), step);
            
            ExecutionResult result = testExecution.join();
            step.complete(result.isSuccess());
            
            if (result.hasSecurityFindings()) {
                session.addError("OpenAPI security issues found: " + result.getSecurityFindings().size());
            }
            
            session.completeStep("OpenAPI Tests", result.isSuccess());
            executionMonitoringService.notifyStepCompleted(session, "OpenAPI Tests", result.isSuccess());
            
        } catch (Exception e) {
            logger.error("Error executing OpenAPI tests", e);
            session.completeStep("OpenAPI Tests", false);
            session.addError("OpenAPI tests failed: " + e.getMessage());
            executionMonitoringService.notifyStepCompleted(session, "OpenAPI Tests", false);
        }
    }
    
    private void executeBpmnTests(TestExecutionSession session, TestExecutionRequest request) {
        logger.info("Executing BPMN tests for session: {}", session.getSessionId());
        session.addStep("BPMN Tests");
        
        try {
            TestExecutionStep step = new TestExecutionStep(
                    session.getSessionId(), 
                    "BPMN Process Test Execution", 
                    TestExecutionStep.StepType.BPMN_PROCESS_TEST
            );
            
            step.setTargetComponent(request.getBpmnProcessId());
            step.setTestType("PROCESS_VALIDATION");
            step.start();
            
            // Выполняем BPMN тесты
            CompletableFuture<ExecutionResult> testExecution = 
                    testExecutionEngine.executeBpmnTests(request.getBpmnProcessId(), step);
            
            ExecutionResult result = testExecution.join();
            step.complete(result.isSuccess());
            
            session.completeStep("BPMN Tests", result.isSuccess());
            executionMonitoringService.notifyStepCompleted(session, "BPMN Tests", result.isSuccess());
            
        } catch (Exception e) {
            logger.error("Error executing BPMN tests", e);
            session.completeStep("BPMN Tests", false);
            session.addError("BPMN tests failed: " + e.getMessage());
            executionMonitoringService.notifyStepCompleted(session, "BPMN Tests", false);
        }
    }
    
    private void executeOwaspTests(TestExecutionSession session, TestExecutionRequest request) {
        logger.info("Executing OWASP tests for session: {}", session.getSessionId());
        session.addStep("OWASP Security Tests");
        
        try {
            TestExecutionStep step = new TestExecutionStep(
                    session.getSessionId(), 
                    "OWASP Security Test Execution", 
                    TestExecutionStep.StepType.OWASP_SECURITY_TEST
            );
            
            step.setTargetComponent("OWASP Categories: " + String.join(", ", request.getOwaspCategories()));
            step.setTestType("SECURITY");
            step.start();
            
            // Выполняем OWASP тесты
            CompletableFuture<ExecutionResult> testExecution = 
                    testExecutionEngine.executeOwaspTests(
                            request.getOpenApiServiceId(), 
                            request.getBpmnProcessId(),
                            request.getOwaspCategories(), 
                            step
                    );
            
            ExecutionResult result = testExecution.join();
            step.complete(result.isSuccess());
            
            if (result.hasSecurityFindings()) {
                session.addWarning("Security vulnerabilities detected: " + result.getVulnerabilities().size());
            }
            
            session.completeStep("OWASP Security Tests", result.isSuccess());
            executionMonitoringService.notifyStepCompleted(session, "OWASP Security Tests", result.isSuccess());
            
        } catch (Exception e) {
            logger.error("Error executing OWASP tests", e);
            session.completeStep("OWASP Security Tests", false);
            session.addError("OWASP tests failed: " + e.getMessage());
            executionMonitoringService.notifyStepCompleted(session, "OWASP Security Tests", false);
        }
    }
    
    private void executeIntegrationTests(TestExecutionSession session, TestExecutionRequest request) {
        logger.info("Executing integration tests for session: {}", session.getSessionId());
        session.addStep("Integration Tests");
        
        try {
            TestExecutionStep step = new TestExecutionStep(
                    session.getSessionId(), 
                    "End-to-End Integration Test", 
                    TestExecutionStep.StepType.INTEGRATION_TEST
            );
            
            step.setTargetComponent("E2E Integration");
            step.setTestType("INTEGRATION");
            step.start();
            
            // Выполняем интеграционные тесты
            CompletableFuture<ExecutionResult> testExecution = 
                    testExecutionEngine.executeIntegrationTests(session, step);
            
            ExecutionResult result = testExecution.join();
            step.complete(result.isSuccess());
            
            session.completeStep("Integration Tests", result.isSuccess());
            executionMonitoringService.notifyStepCompleted(session, "Integration Tests", result.isSuccess());
            
        } catch (Exception e) {
            logger.error("Error executing integration tests", e);
            session.completeStep("Integration Tests", false);
            session.addError("Integration tests failed: " + e.getMessage());
            executionMonitoringService.notifyStepCompleted(session, "Integration Tests", false);
        }
    }
    
    private CompletableFuture<TestExecutionSession> analyzeResultsWithLLM(TestExecutionSession session) {
        logger.info("Starting LLM analysis for session: {}", session.getSessionId());
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                session.addStep("LLM Analysis");
                session.setStatus(TestExecutionSession.SessionStatus.ANALYZING_RESULTS);
                executionMonitoringService.notifySessionStatusUpdate(session);
                
                // Анализируем результаты с помощью LLM
                String llmAnalysis = llmAnalysisService.analyzeExecutionResults(
                        session.getSessionId(),
                        LLMAnalysisType.COMPREHENSIVE_ANALYSIS
                );
                
                session.setLlmAnalysisResult(llmAnalysis);
                session.completeStep("LLM Analysis", true);
                
                logger.info("LLM analysis completed for session: {}", session.getSessionId());
                return session;
                
            } catch (Exception e) {
                logger.error("Error in LLM analysis for session: {}", session.getSessionId(), e);
                session.completeStep("LLM Analysis", false);
                session.addError("LLM analysis failed: " + e.getMessage());
                return session;
            }
        }, executionExecutor);
    }
    
    private TestExecutionSession finalizeSession(TestExecutionSession session) {
        logger.info("Finalizing session: {}", session.getSessionId());
        
        session.setStatus(TestExecutionSession.SessionStatus.GENERATING_REPORT);
        executionMonitoringService.notifySessionStatusUpdate(session);
        
        // Генерируем итоговый отчет
        String comprehensiveReport = generateComprehensiveReport(session);
        session.setComprehensiveReport(comprehensiveReport);
        
        // Завершаем сессию
        session.setStatus(session.isSuccess() ? 
                TestExecutionSession.SessionStatus.COMPLETED : 
                TestExecutionSession.SessionStatus.FAILED);
        
        executionMonitoringService.notifySessionCompleted(session);
        
        return session;
    }
    
    private String generateComprehensiveReport(TestExecutionSession session) {
        StringBuilder report = new StringBuilder();
        report.append("# End-to-End Test Execution Report\n\n");
        report.append("**Session ID:** ").append(session.getSessionId()).append("\n");
        report.append("**Session Name:** ").append(session.getSessionName()).append("\n");
        report.append("**Status:** ").append(session.getStatus()).append("\n");
        report.append("**Started:** ").append(session.getStartedAt()).append("\n");
        report.append("**Completed:** ").append(session.getCompletedAt()).append("\n");
        report.append("**Duration:** ").append(session.getTotalDurationMs()).append(" ms\n\n");
        
        report.append("## Summary\n");
        report.append("- **Total Steps:** ").append(session.getTotalSteps()).append("\n");
        report.append("- **Completed Steps:** ").append(session.getCompletedSteps()).append("\n");
        report.append("- **Passed Steps:** ").append(session.getPassedSteps()).append("\n");
        report.append("- **Failed Steps:** ").append(session.getFailedSteps()).append("\n");
        report.append("- **Success Rate:** ").append(String.format("%.2f%%", session.getSuccessRate())).append("\n\n");
        
        if (session.getLlmAnalysisResult() != null) {
            report.append("## LLM Analysis\n");
            report.append(session.getLlmAnalysisResult()).append("\n\n");
        }
        
        if (!session.getWarnings().isEmpty()) {
            report.append("## Warnings\n");
            for (String warning : session.getWarnings()) {
                report.append("- ").append(warning).append("\n");
            }
            report.append("\n");
        }
        
        if (!session.getCriticalErrors().isEmpty()) {
            report.append("## Critical Errors\n");
            for (String error : session.getCriticalErrors()) {
                report.append("- ").append(error).append("\n");
            }
            report.append("\n");
        }
        
        return report.toString();
    }
    
    private TestExecutionStep createOpenApiTestStep(TestExecutionRequest request) {
        TestExecutionStep step = new TestExecutionStep();
        step.setStepName("OpenAPI Test Execution");
        step.setStepType(TestExecutionStep.StepType.OPENAPI_TEST);
        step.setTargetComponent(request.getOpenApiServiceId());
        step.setTestType("API_VALIDATION");
        step.setStepOrder(1);
        return step;
    }
    
    private TestExecutionStep createBpmnTestStep(TestExecutionRequest request) {
        TestExecutionStep step = new TestExecutionStep();
        step.setStepName("BPMN Process Test");
        step.setStepType(TestExecutionStep.StepType.BPMN_PROCESS_TEST);
        step.setTargetComponent(request.getBpmnProcessId());
        step.setTestType("PROCESS_VALIDATION");
        step.setStepOrder(2);
        return step;
    }
    
    private TestExecutionStep createOwaspTestStep(TestExecutionRequest request) {
        TestExecutionStep step = new TestExecutionStep();
        step.setStepName("OWASP Security Tests");
        step.setStepType(TestExecutionStep.StepType.OWASP_SECURITY_TEST);
        step.setTargetComponent("OWASP Categories: " + String.join(", ", request.getOwaspCategories()));
        step.setTestType("SECURITY");
        step.setStepOrder(3);
        return step;
    }
    
    private TestExecutionStep createDataGenerationStep(TestExecutionRequest request) {
        TestExecutionStep step = new TestExecutionStep();
        step.setStepName("Test Data Generation");
        step.setStepType(TestExecutionStep.StepType.TEST_DATA_GENERATION);
        step.setTargetComponent(request.getTestDataContextId());
        step.setTestType("DATA_PREPARATION");
        step.setStepOrder(0);
        return step;
    }
    
    private TestExecutionStep createLLMAnalysisStep(TestExecutionRequest request) {
        TestExecutionStep step = new TestExecutionStep();
        step.setStepName("LLM Analysis");
        step.setStepType(TestExecutionStep.StepType.LLM_ANALYSIS);
        step.setTargetComponent("Result Analysis");
        step.setTestType("ANALYSIS");
        step.setStepOrder(4);
        return step;
    }
    
    private TestExecutionRequest createRetryRequest(TestExecutionSession originalSession) {
        TestExecutionRequest retryRequest = new TestExecutionRequest();
        retryRequest.setSessionName(originalSession.getSessionName() + " (Retry " + (originalSession.getRetryCount() + 1) + ")");
        retryRequest.setDescription("Retry of failed session: " + originalSession.getSessionId());
        retryRequest.setInitiatedBy("system");
        retryRequest.setOpenApiServiceId(originalSession.getOpenApiServiceId());
        retryRequest.setBpmnProcessId(originalSession.getBpmnProcessId());
        retryRequest.setTestDataContextId(originalSession.getTestDataContextId());
        retryRequest.setOwaspTestCategories(originalSession.getOwaspTestCategories());
        retryRequest.setIsDebugMode(true);
        return retryRequest;
    }
    
    /**
     * Запрос на выполнение тестирования
     */
    public static class TestExecutionRequest {
        private String sessionName;
        private String description;
        private String initiatedBy;
        private String openApiServiceId;
        private String bpmnProcessId;
        private String testDataContextId;
        private List<String> owaspTestCategories;
        private String configuration;
        private String environment = "TEST";
        private Boolean isAutomatedExecution = true;
        private Boolean isParallelExecution = false;
        private Boolean isDebugMode = false;
        
        // Getters and Setters
        public String getSessionName() { return sessionName; }
        public void setSessionName(String sessionName) { this.sessionName = sessionName; }
        
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        
        public String getInitiatedBy() { return initiatedBy; }
        public void setInitiatedBy(String initiatedBy) { this.initiatedBy = initiatedBy; }
        
        public String getOpenApiServiceId() { return openApiServiceId; }
        public void setOpenApiServiceId(String openApiServiceId) { this.openApiServiceId = openApiServiceId; }
        
        public String getBpmnProcessId() { return bpmnProcessId; }
        public void setBpmnProcessId(String bpmnProcessId) { this.bpmnProcessId = bpmnProcessId; }
        
        public String getTestDataContextId() { return testDataContextId; }
        public void setTestDataContextId(String testDataContextId) { this.testDataContextId = testDataContextId; }
        
        public List<String> getOwaspTestCategories() { return owaspTestCategories; }
        public void setOwaspTestCategories(List<String> owaspTestCategories) { this.owaspTestCategories = owaspTestCategories; }
        
        public String getConfiguration() { return configuration; }
        public void setConfiguration(String configuration) { this.configuration = configuration; }
        
        public String getEnvironment() { return environment; }
        public void setEnvironment(String environment) { this.environment = environment; }
        
        public Boolean getIsAutomatedExecution() { return isAutomatedExecution; }
        public void setIsAutomatedExecution(Boolean isAutomatedExecution) { this.isAutomatedExecution = isAutomatedExecution; }
        
        public Boolean getIsParallelExecution() { return isParallelExecution; }
        public void setIsParallelExecution(Boolean isParallelExecution) { this.isParallelExecution = isParallelExecution; }
        
        public Boolean getIsDebugMode() { return isDebugMode; }
        public void setIsDebugMode(Boolean isDebugMode) { this.isDebugMode = isDebugMode; }
    }
    
    /**
     * Детали сессии выполнения
     */
    public static class TestExecutionSessionDetails {
        private TestExecutionSession session;
        private List<TestExecutionStep> steps;
        private List<ExecutionResult> results;
        private List<ErrorLog> errors;
        private List<TestPerformanceMetrics> metrics;
        private String llmAnalysis;
        
        private TestExecutionSessionDetails(Builder builder) {
            this.session = builder.session;
            this.steps = builder.steps;
            this.results = builder.results;
            this.errors = builder.errors;
            this.metrics = builder.metrics;
            this.llmAnalysis = builder.llmAnalysis;
        }
        
        public static Builder builder() {
            return new Builder();
        }
        
        public static class Builder {
            private TestExecutionSession session;
            private List<TestExecutionStep> steps = new ArrayList<>();
            private List<ExecutionResult> results = new ArrayList<>();
            private List<ErrorLog> errors = new ArrayList<>();
            private List<TestPerformanceMetrics> metrics = new ArrayList<>();
            private String llmAnalysis;
            
            public Builder session(TestExecutionSession session) {
                this.session = session;
                return this;
            }
            
            public Builder steps(List<TestExecutionStep> steps) {
                this.steps = steps;
                return this;
            }
            
            public Builder results(List<ExecutionResult> results) {
                this.results = results;
                return this;
            }
            
            public Builder errors(List<ErrorLog> errors) {
                this.errors = errors;
                return this;
            }
            
            public Builder metrics(List<TestPerformanceMetrics> metrics) {
                this.metrics = metrics;
                return this;
            }
            
            public Builder llmAnalysis(String llmAnalysis) {
                this.llmAnalysis = llmAnalysis;
                return this;
            }
            
            public TestExecutionSessionDetails build() {
                return new TestExecutionSessionDetails(this);
            }
        }
        
        // Getters
        public TestExecutionSession getSession() { return session; }
        public List<TestExecutionStep> getSteps() { return steps; }
        public List<ExecutionResult> getResults() { return results; }
        public List<ErrorLog> getErrors() { return errors; }
        public List<TestPerformanceMetrics> getMetrics() { return metrics; }
        public String getLlmAnalysis() { return llmAnalysis; }
    }
    
    /**
     * План выполнения тестов
     */
    public static class TestExecutionPlan {
        private String sessionName;
        private String description;
        private List<TestExecutionStep> steps = new ArrayList<>();
        
        private TestExecutionPlan(Builder builder) {
            this.sessionName = builder.sessionName;
            this.description = builder.description;
            this.steps = builder.steps;
        }
        
        public static Builder builder() {
            return new Builder();
        }
        
        public static class Builder {
            private String sessionName;
            private String description;
            private List<TestExecutionStep> steps = new ArrayList<>();
            
            public Builder sessionName(String sessionName) {
                this.sessionName = sessionName;
                return this;
            }
            
            public Builder description(String description) {
                this.description = description;
                return this;
            }
            
            public Builder addStep(TestExecutionStep step) {
                this.steps.add(step);
                return this;
            }
            
            public TestExecutionPlan build() {
                return new TestExecutionPlan(this);
            }
        }
        
        // Getters
        public String getSessionName() { return sessionName; }
        public String getDescription() { return description; }
        public List<TestExecutionStep> getSteps() { return steps; }
    }
    
    /**
     * Типы LLM анализа
     */
    public enum LLMAnalysisType {
        COMPREHENSIVE_ANALYSIS,
        ERROR_ANALYSIS,
        PERFORMANCE_ANALYSIS,
        SECURITY_ANALYSIS,
        QUALITY_ANALYSIS,
        RECOMMENDATIONS
    }
    
    /**
     * Закрытие ресурсов при завершении работы
     */
    public void shutdown() {
        logger.info("Shutting down EndToEndTestExecutionService");
        executionExecutor.shutdown();
    }
}