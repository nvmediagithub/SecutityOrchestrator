package org.example.infrastructure.services.datamanagement;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Service for managing data retention policies and lifecycle
 */
@Service
@Transactional
public class DataRetentionService {
    
    @Autowired
    private RetentionPolicyRepository retentionPolicyRepository;
    
    @Autowired
    private TestDataRepository testDataRepository;
    
    // Policy Management Methods
    
    /**
     * Create a new retention policy
     */
    public RetentionPolicy createPolicy(String name, String dataType, Integer retentionDays, String userId) {
        RetentionPolicy policy = new RetentionPolicy(name, dataType, retentionDays);
        policy.setCreatedBy(userId);
        policy.setEffectiveFrom(LocalDateTime.now());
        
        return retentionPolicyRepository.save(policy);
    }
    
    /**
     * Get retention policy
     */
    public Optional<RetentionPolicy> getPolicy(String policyId) {
        return retentionPolicyRepository.findByPolicyId(policyId);
    }
    
    /**
     * Get all active policies
     */
    public List<RetentionPolicy> getActivePolicies() {
        return retentionPolicyRepository.findByIsActiveTrue();
    }
    
    /**
     * Update retention policy
     */
    public RetentionPolicy updatePolicy(String policyId, Integer retentionDays, Integer archiveDays, String userId) {
        RetentionPolicy policy = retentionPolicyRepository.findByPolicyId(policyId)
                .orElseThrow(() -> new IllegalArgumentException("Policy not found: " + policyId));
        
        policy.setRetentionDays(retentionDays);
        if (archiveDays != null) {
            policy.setArchiveDays(archiveDays);
        }
        policy.setLastModifiedBy(userId);
        policy.setUpdatedAt(LocalDateTime.now());
        
        return retentionPolicyRepository.save(policy);
    }
    
    // Data Lifecycle Management Methods
    
    /**
     * Check which data sets need archiving based on policies
     */
    public List<TestDataSet> findDataSetsForArchiving() {
        List<TestDataSet> dataSetsForArchiving = new ArrayList<>();
        List<RetentionPolicy> activePolicies = getActivePolicies();
        
        for (TestDataSet dataSet : testDataRepository.findAll()) {
            for (RetentionPolicy policy : activePolicies) {
                if (shouldArchiveDataSet(dataSet, policy)) {
                    dataSetsForArchiving.add(dataSet);
                    break; // Only add once per data set
                }
            }
        }
        
        return dataSetsForArchiving;
    }
    
    /**
     * Check which data sets need deletion based on policies
     */
    public List<TestDataSet> findDataSetsForDeletion() {
        List<TestDataSet> dataSetsForDeletion = new ArrayList<>();
        List<RetentionPolicy> activePolicies = getActivePolicies();
        
        for (TestDataSet dataSet : testDataRepository.findAll()) {
            for (RetentionPolicy policy : activePolicies) {
                if (shouldDeleteDataSet(dataSet, policy)) {
                    dataSetsForDeletion.add(dataSet);
                    break; // Only add once per data set
                }
            }
        }
        
        return dataSetsForDeletion;
    }
    
    /**
     * Execute archiving for data sets
     */
    public ArchiveReport archiveDataSets(List<String> dataSetIds, String userId) {
        List<String> successfullyArchived = new ArrayList<>();
        List<String> failedToArchive = new ArrayList<>();
        
        for (String dataSetId : dataSetIds) {
            try {
                Optional<TestDataSet> dataSetOpt = testDataRepository.findByDataSetId(dataSetId);
                if (dataSetOpt.isPresent()) {
                    TestDataSet dataSet = dataSetOpt.get();
                    dataSet.archive();
                    dataSet.setLastModifiedBy(userId);
                    testDataRepository.save(dataSet);
                    
                    successfullyArchived.add(dataSetId);
                    
                    // Log the action
                    // In real implementation, would log to audit table
                } else {
                    failedToArchive.add(dataSetId + " (not found)");
                }
            } catch (Exception e) {
                failedToArchive.add(dataSetId + " (error: " + e.getMessage() + ")");
            }
        }
        
        return new ArchiveReport(successfullyArchived, failedToArchive, userId);
    }
    
    /**
     * Execute deletion for data sets
     */
    public DeletionReport deleteDataSets(List<String> dataSetIds, String userId) {
        List<String> successfullyDeleted = new ArrayList<>();
        List<String> failedToDelete = new ArrayList<>();
        
        for (String dataSetId : dataSetIds) {
            try {
                Optional<TestDataSet> dataSetOpt = testDataRepository.findByDataSetId(dataSetId);
                if (dataSetOpt.isPresent()) {
                    TestDataSet dataSet = dataSetOpt.get();
                    
                    // Check if deletion is allowed
                    if (canDeleteDataSet(dataSet)) {
                        testDataRepository.delete(dataSet);
                        successfullyDeleted.add(dataSetId);
                        
                        // Log the action
                        // In real implementation, would log to audit table
                    } else {
                        failedToDelete.add(dataSetId + " (deletion not allowed)");
                    }
                } else {
                    failedToDelete.add(dataSetId + " (not found)");
                }
            } catch (Exception e) {
                failedToDelete.add(dataSetId + " (error: " + e.getMessage() + ")");
            }
        }
        
        return new DeletionReport(successfullyDeleted, failedToDelete, userId);
    }
    
    // Automated Retention Processing
    
    /**
     * Scheduled method to process retention policies daily
     */
    @Scheduled(cron = "0 0 2 * * ?") // Run at 2 AM daily
    public void processRetentionPolicies() {
        try {
            List<TestDataSet> dataSetsForArchiving = findDataSetsForArchiving();
            List<TestDataSet> dataSetsForDeletion = findDataSetsForDeletion();
            
            if (!dataSetsForArchiving.isEmpty()) {
                List<String> dataSetIds = dataSetsForArchiving.stream()
                        .map(TestDataSet::getDataSetId)
                        .collect(Collectors.toList());
                archiveDataSets(dataSetIds, "SYSTEM");
            }
            
            if (!dataSetsForDeletion.isEmpty()) {
                List<String> dataSetIds = dataSetsForDeletion.stream()
                        .map(TestDataSet::getDataSetId)
                        .collect(Collectors.toList());
                deleteDataSets(dataSetIds, "SYSTEM");
            }
            
        } catch (Exception e) {
            // Log error but don't throw - scheduled method should be resilient
            System.err.println("Error processing retention policies: " + e.getMessage());
        }
    }
    
    // Compliance and Reporting Methods
    
    /**
     * Generate retention compliance report
     */
    public RetentionComplianceReport generateComplianceReport() {
        List<TestDataSet> allDataSets = testDataRepository.findAll();
        List<RetentionPolicy> activePolicies = getActivePolicies();
        
        Map<String, Object> statistics = new HashMap<>();
        List<String> violations = new ArrayList<>();
        List<String> recommendations = new ArrayList<>();
        
        // Calculate statistics
        long totalDataSets = allDataSets.size();
        long archivedDataSets = allDataSets.stream()
                .mapToLong(ds -> Boolean.TRUE.equals(ds.getIsArchived()) ? 1 : 0)
                .sum();
        long activeDataSets = totalDataSets - archivedDataSets;
        
        statistics.put("totalDataSets", totalDataSets);
        statistics.put("activeDataSets", activeDataSets);
        statistics.put("archivedDataSets", archivedDataSets);
        statistics.put("activePolicies", activePolicies.size());
        
        // Check for policy violations
        for (TestDataSet dataSet : allDataSets) {
            if (isRetentionPolicyViolated(dataSet, activePolicies)) {
                violations.add("Data set " + dataSet.getDataSetId() + " violates retention policy");
            }
        }
        
        // Generate recommendations
        if (activePolicies.isEmpty()) {
            recommendations.add("No active retention policies found - create policies for data governance");
        }
        
        long oldDataSets = allDataSets.stream()
                .mapToLong(ds -> {
                    if (ds.getCreatedAt() != null) {
                        long daysOld = ChronoUnit.DAYS.between(ds.getCreatedAt(), LocalDateTime.now());
                        return daysOld > 365 ? 1 : 0; // Older than 1 year
                    }
                    return 0;
                })
                .sum();
        
        if (oldDataSets > 0) {
            recommendations.add("Found " + oldDataSets + " data sets older than 1 year - review for archiving");
        }
        
        return new RetentionComplianceReport(statistics, violations, recommendations);
    }
    
    /**
     * Get data sets by age
     */
    public List<TestDataSet> getDataSetsByAge(int minDaysOld) {
        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(minDaysOld);
        return testDataRepository.findByCreatedAtBefore(cutoffDate);
    }
    
    /**
     * Calculate storage savings from archiving
     */
    public StorageSavingsReport calculateStorageSavings() {
        List<TestDataSet> archivedDataSets = testDataRepository.findByIsArchivedTrue();
        List<TestDataSet> activeDataSets = testDataRepository.findByIsArchivedFalse();
        
        long archivedSize = archivedDataSets.stream()
                .mapToLong(ds -> ds.getDataSize() != null ? ds.getDataSize() : 0)
                .sum();
        
        long activeSize = activeDataSets.stream()
                .mapToLong(ds -> ds.getDataSize() != null ? ds.getDataSize() : 0)
                .sum();
        
        return new StorageSavingsReport(archivedSize, activeSize, archivedDataSets.size(), activeDataSets.size());
    }
    
    // Private Helper Methods
    
    private boolean shouldArchiveDataSet(TestDataSet dataSet, RetentionPolicy policy) {
        if (dataSet.getCreatedAt() == null || policy.getArchiveDays() == null) {
            return false;
        }
        
        LocalDateTime archiveDate = dataSet.getCreatedAt().plusDays(policy.getArchiveDays());
        return LocalDateTime.now().isAfter(archiveDate) && !Boolean.TRUE.equals(dataSet.getIsArchived());
    }
    
    private boolean shouldDeleteDataSet(TestDataSet dataSet, RetentionPolicy policy) {
        if (dataSet.getCreatedAt() == null || policy.getRetentionDays() == null) {
            return false;
        }
        
        LocalDateTime deletionDate = dataSet.getCreatedAt().plusDays(policy.getRetentionDays());
        boolean isOldEnough = LocalDateTime.now().isAfter(deletionDate);
        
        // Check grace period
        if (policy.hasGracePeriod()) {
            LocalDateTime graceEndDate = deletionDate.plusDays(policy.getGracePeriodDays());
            return LocalDateTime.now().isAfter(graceEndDate);
        }
        
        return isOldEnough;
    }
    
    private boolean canDeleteDataSet(TestDataSet dataSet) {
        // Check if data set has any legal holds or compliance requirements
        // Simplified implementation
        return !Boolean.TRUE.equals(dataSet.getIsArchived()) || // Only delete non-archived data
               (dataSet.getCreatedAt() != null && ChronoUnit.DAYS.between(dataSet.getCreatedAt(), LocalDateTime.now()) > 30);
    }
    
    private boolean isRetentionPolicyViolated(TestDataSet dataSet, List<RetentionPolicy> policies) {
        for (RetentionPolicy policy : policies) {
            if (shouldDeleteDataSet(dataSet, policy) && !dataSet.getIsArchived()) {
                return true;
            }
        }
        return false;
    }
    
    // Inner classes for return types
    
    public static class ArchiveReport {
        private final List<String> successfullyArchived;
        private final List<String> failedToArchive;
        private final String executedBy;
        private final LocalDateTime executedAt;
        
        public ArchiveReport(List<String> successfullyArchived, List<String> failedToArchive, String executedBy) {
            this.successfullyArchived = successfullyArchived != null ? successfullyArchived : new ArrayList<>();
            this.failedToArchive = failedToArchive != null ? failedToArchive : new ArrayList<>();
            this.executedBy = executedBy;
            this.executedAt = LocalDateTime.now();
        }
        
        // Getters
        public List<String> getSuccessfullyArchived() { return successfullyArchived; }
        public List<String> getFailedToArchive() { return failedToArchive; }
        public String getExecutedBy() { return executedBy; }
        public LocalDateTime getExecutedAt() { return executedAt; }
        
        public int getTotalProcessed() {
            return successfullyArchived.size() + failedToArchive.size();
        }
        
        public int getSuccessCount() {
            return successfullyArchived.size();
        }
        
        public int getFailureCount() {
            return failedToArchive.size();
        }
    }
    
    public static class DeletionReport {
        private final List<String> successfullyDeleted;
        private final List<String> failedToDelete;
        private final String executedBy;
        private final LocalDateTime executedAt;
        
        public DeletionReport(List<String> successfullyDeleted, List<String> failedToDelete, String executedBy) {
            this.successfullyDeleted = successfullyDeleted != null ? successfullyDeleted : new ArrayList<>();
            this.failedToDelete = failedToDelete != null ? failedToDelete : new ArrayList<>();
            this.executedBy = executedBy;
            this.executedAt = LocalDateTime.now();
        }
        
        // Getters
        public List<String> getSuccessfullyDeleted() { return successfullyDeleted; }
        public List<String> getFailedToDelete() { return failedToDelete; }
        public String getExecutedBy() { return executedBy; }
        public LocalDateTime getExecutedAt() { return executedAt; }
        
        public int getTotalProcessed() {
            return successfullyDeleted.size() + failedToDelete.size();
        }
        
        public int getSuccessCount() {
            return successfullyDeleted.size();
        }
        
        public int getFailureCount() {
            return failedToDelete.size();
        }
    }
    
    public static class RetentionComplianceReport {
        private final Map<String, Object> statistics;
        private final List<String> violations;
        private final List<String> recommendations;
        
        public RetentionComplianceReport(Map<String, Object> statistics, List<String> violations, List<String> recommendations) {
            this.statistics = statistics != null ? statistics : new HashMap<>();
            this.violations = violations != null ? violations : new ArrayList<>();
            this.recommendations = recommendations != null ? recommendations : new ArrayList<>();
        }
        
        // Getters
        public Map<String, Object> getStatistics() { return statistics; }
        public List<String> getViolations() { return violations; }
        public List<String> getRecommendations() { return recommendations; }
        
        public boolean isCompliant() {
            return violations.isEmpty();
        }
        
        public int getViolationCount() {
            return violations.size();
        }
        
        public int getRecommendationCount() {
            return recommendations.size();
        }
    }
    
    public static class StorageSavingsReport {
        private final long archivedSizeBytes;
        private final long activeSizeBytes;
        private final int archivedDataSetCount;
        private final int activeDataSetCount;
        
        public StorageSavingsReport(long archivedSizeBytes, long activeSizeBytes, int archivedDataSetCount, int activeDataSetCount) {
            this.archivedSizeBytes = archivedSizeBytes;
            this.activeSizeBytes = activeSizeBytes;
            this.archivedDataSetCount = archivedDataSetCount;
            this.activeDataSetCount = activeDataSetCount;
        }
        
        // Getters
        public long getArchivedSizeBytes() { return archivedSizeBytes; }
        public long getActiveSizeBytes() { return activeSizeBytes; }
        public int getArchivedDataSetCount() { return archivedDataSetCount; }
        public int getActiveDataSetCount() { return activeDataSetCount; }
        
        public long getTotalSizeBytes() {
            return archivedSizeBytes + activeSizeBytes;
        }
        
        public double getArchivedSizeMB() {
            return archivedSizeBytes / (1024.0 * 1024.0);
        }
        
        public double getActiveSizeMB() {
            return activeSizeBytes / (1024.0 * 1024.0);
        }
        
        public double getTotalSizeMB() {
            return getTotalSizeBytes() / (1024.0 * 1024.0);
        }
        
        public double getArchivePercentage() {
            long total = getTotalSizeBytes();
            return total > 0 ? (double) archivedSizeBytes / total * 100 : 0;
        }
    }
}