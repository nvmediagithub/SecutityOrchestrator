package org.example.infrastructure.services.bpmn.analyzers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Маппер BPMN элементов к API endpoints
 * Обеспечивает mapping между BPMN процессами и REST API
 */
public class BpmnApiMapper {
    
    private static final Logger logger = LoggerFactory.getLogger(BpmnApiMapper.class);
    
    private final Builder builder;
    
    private BpmnApiMapper(Builder builder) {
        this.builder = builder;
    }
    
    public static class Builder {
        private boolean mapTasksToEndpoints = true;
        private boolean mapEventsToTriggers = true;
        private boolean mapGatewaysToDecisions = true;
        private boolean mapSubProcessesToResources = true;
        private boolean generateOpenApiSpec = false;
        private String basePath = "/api/v1";
        private List<String> supportedMethods = Arrays.asList("GET", "POST", "PUT", "DELETE", "PATCH");
        private Map<String, String> taskToMethodMapping = new HashMap<>();
        private Map<String, String> taskToPathMapping = new HashMap<>();
        
        public Builder setMapTasksToEndpoints(boolean mapTasksToEndpoints) {
            this.mapTasksToEndpoints = mapTasksToEndpoints;
            return this;
        }
        
        public Builder setMapEventsToTriggers(boolean mapEventsToTriggers) {
            this.mapEventsToTriggers = mapEventsToTriggers;
            return this;
        }
        
        public Builder setMapGatewaysToDecisions(boolean mapGatewaysToDecisions) {
            this.mapGatewaysToDecisions = mapGatewaysToDecisions;
            return this;
        }
        
        public Builder setMapSubProcessesToResources(boolean mapSubProcessesToResources) {
            this.mapSubProcessesToResources = mapSubProcessesToResources;
            return this;
        }
        
        public Builder setGenerateOpenApiSpec(boolean generateOpenApiSpec) {
            this.generateOpenApiSpec = generateOpenApiSpec;
            return this;
        }
        
        public Builder setBasePath(String basePath) {
            if (basePath == null || basePath.trim().isEmpty()) {
                throw new IllegalArgumentException("Base path cannot be null or empty");
            }
            this.basePath = basePath;
            return this;
        }
        
        public Builder setSupportedMethods(List<String> supportedMethods) {
            if (supportedMethods == null || supportedMethods.isEmpty()) {
                throw new IllegalArgumentException("Supported methods cannot be null or empty");
            }
            this.supportedMethods = new ArrayList<>(supportedMethods);
            return this;
        }
        
        public Builder addTaskMethodMapping(String taskType, String httpMethod) {
            if (taskType != null && httpMethod != null) {
                this.taskToMethodMapping.put(taskType, httpMethod.toUpperCase());
            }
            return this;
        }
        
        public Builder addTaskPathMapping(String taskType, String path) {
            if (taskType != null && path != null) {
                this.taskToPathMapping.put(taskType, path);
            }
            return this;
        }
        
        public BpmnApiMapper build() {
            // Initialize default mappings if empty
            if (taskToMethodMapping.isEmpty()) {
                taskToMethodMapping.put("userTask", "POST");
                taskToMethodMapping.put("serviceTask", "POST");
                taskToMethodMapping.put("task", "POST");
            }
            
            if (taskToPathMapping.isEmpty()) {
                taskToPathMapping.put("userTask", "/users");
                taskToPathMapping.put("serviceTask", "/services");
                taskToPathMapping.put("task", "/tasks");
            }
            
            return new BpmnApiMapper(this);
        }
    }
    
    public static Builder builder() {
        return new Builder();
    }
    
    /**
     * Создает mapping BPMN элементов к API endpoints
     */
    public CompletableFuture<BpmnApiMapping> createApiMapping(String bpmnXml) {
        logger.info("Creating API mapping for BPMN process");
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                validateBpmnInput(bpmnXml);
                
                BpmnApiMapping mapping = new BpmnApiMapping();
                mapping.setBasePath(builder.basePath);
                
                // Extract process information
                Map<String, Object> processInfo = extractProcessInfo(bpmnXml);
                mapping.setProcessName((String) processInfo.get("name"));
                mapping.setProcessId((String) processInfo.get("id"));
                
                // Map BPMN elements to API
                if (builder.mapTasksToEndpoints) {
                    List<ApiEndpoint> endpoints = mapTasksToEndpoints(bpmnXml);
                    mapping.setEndpoints(endpoints);
                }
                
                if (builder.mapEventsToTriggers) {
                    List<ApiTrigger> triggers = mapEventsToTriggers(bpmnXml);
                    mapping.setTriggers(triggers);
                }
                
                if (builder.mapGatewaysToDecisions) {
                    List<ApiDecision> decisions = mapGatewaysToDecisions(bpmnXml);
                    mapping.setDecisions(decisions);
                }
                
                if (builder.mapSubProcessesToResources) {
                    List<ApiResource> resources = mapSubProcessesToResources(bpmnXml);
                    mapping.setResources(resources);
                }
                
                // Generate OpenAPI spec if requested
                if (builder.generateOpenApiSpec) {
                    String openApiSpec = generateOpenApiSpec(mapping);
                    mapping.setOpenApiSpec(openApiSpec);
                }
                
                // Calculate mapping quality
                double qualityScore = calculateMappingQuality(mapping);
                mapping.setQualityScore(qualityScore);
                
                // Generate recommendations
                List<String> recommendations = generateMappingRecommendations(mapping);
                mapping.setRecommendations(recommendations);
                
                logger.info("API mapping completed with quality score: {}", qualityScore);
                return mapping;
                
            } catch (Exception e) {
                logger.error("Failed to create API mapping", e);
                return createErrorMapping(e);
            }
        });
    }
    
    /**
     * Генерирует OpenAPI спецификацию для BPMN процесса
     */
    public CompletableFuture<String> generateOpenApiSpec(String bpmnXml) {
        logger.info("Generating OpenAPI specification from BPMN");
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                BpmnApiMapping mapping = createApiMapping(bpmnXml).join();
                return generateOpenApiSpec(mapping);
            } catch (Exception e) {
                logger.error("Failed to generate OpenAPI spec", e);
                return "Error generating OpenAPI spec: " + e.getMessage();
            }
        });
    }
    
    /**
     * Создает API документацию на основе BPMN
     */
    public CompletableFuture<ApiDocumentation> generateApiDocumentation(String bpmnXml) {
        logger.info("Generating API documentation from BPMN");
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                BpmnApiMapping mapping = createApiMapping(bpmnXml).join();
                
                ApiDocumentation documentation = new ApiDocumentation();
                documentation.setProcessName(mapping.getProcessName());
                documentation.setBasePath(mapping.getBasePath());
                
                // Generate endpoint documentation
                List<EndpointDocumentation> endpointDocs = new ArrayList<>();
                for (ApiEndpoint endpoint : mapping.getEndpoints()) {
                    EndpointDocumentation doc = generateEndpointDocumentation(endpoint);
                    endpointDocs.add(doc);
                }
                documentation.setEndpointDocumentation(endpointDocs);
                
                // Generate workflow documentation
                String workflowDoc = generateWorkflowDocumentation(mapping);
                documentation.setWorkflowDocumentation(workflowDoc);
                
                // Generate examples
                Map<String, Object> examples = generateExamples(mapping);
                documentation.setExamples(examples);
                
                return documentation;
                
            } catch (Exception e) {
                logger.error("Failed to generate API documentation", e);
                ApiDocumentation errorDoc = new ApiDocumentation();
                errorDoc.setErrorMessage("Documentation generation failed: " + e.getMessage());
                return errorDoc;
            }
        });
    }
    
    /**
     * Валидирует BPMN на соответствие REST API patterns
     */
    public CompletableFuture<MappingValidationResult> validateApiMapping(String bpmnXml) {
        logger.info("Validating BPMN to API mapping");
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                BpmnApiMapping mapping = createApiMapping(bpmnXml).join();
                
                MappingValidationResult result = new MappingValidationResult();
                
                // Check for valid HTTP methods
                List<String> httpMethodViolations = validateHttpMethods(mapping);
                result.setHttpMethodViolations(httpMethodViolations);
                
                // Check for valid paths
                List<String> pathViolations = validatePaths(mapping);
                result.setPathViolations(pathViolations);
                
                // Check for naming conventions
                List<String> namingViolations = validateNamingConventions(mapping);
                result.setNamingViolations(namingViolations);
                
                // Check for resource consistency
                List<String> resourceViolations = validateResourceConsistency(mapping);
                result.setResourceViolations(resourceViolations);
                
                // Calculate validation score
                double validationScore = calculateValidationScore(result);
                result.setValidationScore(validationScore);
                
                // Generate recommendations
                List<String> validationRecommendations = generateValidationRecommendations(result);
                result.setRecommendations(validationRecommendations);
                
                return result;
                
            } catch (Exception e) {
                logger.error("Failed to validate API mapping", e);
                MappingValidationResult errorResult = new MappingValidationResult();
                errorResult.setValidationScore(0.0);
                errorResult.setErrorMessage("Validation failed: " + e.getMessage());
                return errorResult;
            }
        });
    }
    
    private void validateBpmnInput(String bpmnXml) {
        if (bpmnXml == null || bpmnXml.trim().isEmpty()) {
            throw new IllegalArgumentException("BPMN XML cannot be null or empty");
        }
        
        if (!bpmnXml.contains("bpmn:definitions") && !bpmnXml.contains("definitions")) {
            throw new IllegalArgumentException("Invalid BPMN XML: missing definitions element");
        }
    }
    
    private Map<String, Object> extractProcessInfo(String bpmnXml) {
        Map<String, Object> processInfo = new HashMap<>();
        
        // Extract process name and ID using simple regex (in real implementation, use proper XML parsing)
        Pattern processPattern = Pattern.compile("<process[^>]*id=\"([^\"]*)\"[^>]*name=\"([^\"]*)\"");
        var matcher = processPattern.matcher(bpmnXml);
        
        if (matcher.find()) {
            processInfo.put("id", matcher.group(1));
            processInfo.put("name", matcher.group(2));
        } else {
            // Fallback values
            processInfo.put("id", "process_" + System.currentTimeMillis());
            processInfo.put("name", "Unnamed Process");
        }
        
        return processInfo;
    }
    
    private List<ApiEndpoint> mapTasksToEndpoints(String bpmnXml) {
        List<ApiEndpoint> endpoints = new ArrayList<>();
        
        // Extract tasks from BPMN XML
        Pattern taskPattern = Pattern.compile("<(userTask|serviceTask|task)[^>]*id=\"([^\"]*)\"[^>]*name=\"([^\"]*)\"");
        var matcher = taskPattern.matcher(bpmnXml);
        
        while (matcher.find()) {
            String taskType = matcher.group(1);
            String taskId = matcher.group(2);
            String taskName = matcher.group(3);
            
            ApiEndpoint endpoint = new ApiEndpoint();
            endpoint.setId("endpoint_" + taskId);
            endpoint.setName(taskName);
            endpoint.setTaskId(taskId);
            endpoint.setTaskType(taskType);
            
            // Determine HTTP method
            String httpMethod = builder.taskToMethodMapping.getOrDefault(taskType, "POST");
            endpoint.setHttpMethod(httpMethod);
            
            // Determine path
            String basePath = builder.taskToPathMapping.getOrDefault(taskType, "/tasks");
            String taskPath = taskName.toLowerCase()
                .replaceAll("\\s+", "_")
                .replaceAll("[^a-z0-9_]", "");
            String fullPath = builder.basePath + basePath + "/" + taskPath;
            endpoint.setPath(fullPath);
            
            // Set default responses
            List<ApiResponse> responses = Arrays.asList(
                new ApiResponse("200", "Success", "application/json"),
                new ApiResponse("400", "Bad Request", "application/json"),
                new ApiResponse("500", "Internal Server Error", "application/json")
            );
            endpoint.setResponses(responses);
            
            endpoints.add(endpoint);
        }
        
        return endpoints;
    }
    
    private List<ApiTrigger> mapEventsToTriggers(String bpmnXml) {
        List<ApiTrigger> triggers = new ArrayList<>();
        
        // Extract start events
        Pattern startEventPattern = Pattern.compile("<startEvent[^>]*id=\"([^\"]*)\"[^>]*name=\"([^\"]*)\"");
        var matcher = startEventPattern.matcher(bpmnXml);
        
        while (matcher.find()) {
            String eventId = matcher.group(1);
            String eventName = matcher.group(2);
            
            ApiTrigger trigger = new ApiTrigger();
            trigger.setId("trigger_" + eventId);
            trigger.setName(eventName);
            trigger.setEventId(eventId);
            trigger.setTriggerType("start");
            trigger.setHttpMethod("POST");
            trigger.setPath(builder.basePath + "/start/" + eventName.toLowerCase().replaceAll("\\s+", "_"));
            
            triggers.add(trigger);
        }
        
        // Extract end events
        Pattern endEventPattern = Pattern.compile("<endEvent[^>]*id=\"([^\"]*)\"[^>]*name=\"([^\"]*)\"");
        matcher = endEventPattern.matcher(bpmnXml);
        
        while (matcher.find()) {
            String eventId = matcher.group(1);
            String eventName = matcher.group(2);
            
            ApiTrigger trigger = new ApiTrigger();
            trigger.setId("trigger_" + eventId);
            trigger.setName(eventName);
            trigger.setEventId(eventId);
            trigger.setTriggerType("end");
            trigger.setHttpMethod("GET");
            trigger.setPath(builder.basePath + "/status/" + eventName.toLowerCase().replaceAll("\\s+", "_"));
            
            triggers.add(trigger);
        }
        
        return triggers;
    }
    
    private List<ApiDecision> mapGatewaysToDecisions(String bpmnXml) {
        List<ApiDecision> decisions = new ArrayList<>();
        
        // Extract exclusive gateways
        Pattern gatewayPattern = Pattern.compile("<exclusiveGateway[^>]*id=\"([^\"]*)\"[^>]*name=\"([^\"]*)\"");
        var matcher = gatewayPattern.matcher(bpmnXml);
        
        while (matcher.find()) {
            String gatewayId = matcher.group(1);
            String gatewayName = matcher.group(2);
            
            ApiDecision decision = new ApiDecision();
            decision.setId("decision_" + gatewayId);
            decision.setName(gatewayName);
            decision.setGatewayId(gatewayId);
            decision.setDecisionType("exclusive");
            decision.setHttpMethod("POST");
            decision.setPath(builder.basePath + "/decisions/" + gatewayName.toLowerCase().replaceAll("\\s+", "_"));
            
            // Extract outgoing sequence flows as possible outcomes
            List<String> outcomes = extractOutcomes(gatewayId, bpmnXml);
            decision.setPossibleOutcomes(outcomes);
            
            decisions.add(decision);
        }
        
        return decisions;
    }
    
    private List<ApiResource> mapSubProcessesToResources(String bpmnXml) {
        List<ApiResource> resources = new ArrayList<>();
        
        // Extract sub-processes
        Pattern subProcessPattern = Pattern.compile("<subProcess[^>]*id=\"([^\"]*)\"[^>]*name=\"([^\"]*)\"");
        var matcher = subProcessPattern.matcher(bpmnXml);
        
        while (matcher.find()) {
            String processId = matcher.group(1);
            String processName = matcher.group(2);
            
            ApiResource resource = new ApiResource();
            resource.setId("resource_" + processId);
            resource.setName(processName);
            resource.setSubProcessId(processId);
            resource.setResourceName(processName.toLowerCase().replaceAll("\\s+", "_") + "s");
            resource.setBasePath(builder.basePath + "/" + processName.toLowerCase().replaceAll("\\s+", "_") + "s");
            
            // Add standard CRUD operations
            List<ApiOperation> operations = Arrays.asList(
                new ApiOperation("GET", "", "Get all " + resource.getResourceName()),
                new ApiOperation("GET", "/{id}", "Get " + resource.getResourceName() + " by ID"),
                new ApiOperation("POST", "", "Create new " + resource.getResourceName()),
                new ApiOperation("PUT", "/{id}", "Update " + resource.getResourceName()),
                new ApiOperation("DELETE", "/{id}", "Delete " + resource.getResourceName())
            );
            resource.setOperations(operations);
            
            resources.add(resource);
        }
        
        return resources;
    }
    
    private List<String> extractOutcomes(String gatewayId, String bpmnXml) {
        List<String> outcomes = new ArrayList<>();
        
        // Look for sequence flows going out from this gateway
        Pattern sequenceFlowPattern = Pattern.compile(
            "<sequenceFlow[^>]*sourceRef=\"" + gatewayId + "\"[^>]*targetRef=\"([^\"]*)\"[^>]*name=\"([^\"]*)\""
        );
        var matcher = sequenceFlowPattern.matcher(bpmnXml);
        
        while (matcher.find()) {
            outcomes.add(matcher.group(2));
        }
        
        return outcomes.isEmpty() ? Arrays.asList("true", "false") : outcomes;
    }
    
    private String generateOpenApiSpec(BpmnApiMapping mapping) {
        StringBuilder spec = new StringBuilder();
        
        spec.append("openapi: 3.0.0\n");
        spec.append("info:\n");
        spec.append("  title: ").append(mapping.getProcessName()).append(" API\n");
        spec.append("  version: 1.0.0\n");
        spec.append("  description: API generated from BPMN process\n\n");
        
        spec.append("servers:\n");
        spec.append("  - url: ").append(mapping.getBasePath()).append("\n\n");
        
        spec.append("paths:\n");
        
        // Add endpoints
        for (ApiEndpoint endpoint : mapping.getEndpoints()) {
            spec.append("  ").append(endpoint.getPath()).append(":\n");
            spec.append("    ").append(endpoint.getHttpMethod().toLowerCase()).append(":\n");
            spec.append("      summary: ").append(endpoint.getName()).append("\n");
            spec.append("      operationId: ").append(endpoint.getId()).append("\n");
            spec.append("      responses:\n");
            
            for (ApiResponse response : endpoint.getResponses()) {
                spec.append("        ").append(response.getCode()).append(":\n");
                spec.append("          description: ").append(response.getDescription()).append("\n");
                spec.append("          content:\n");
                spec.append("            ").append(response.getContentType()).append(":\n");
                spec.append("              schema:\n");
                spec.append("                type: object\n");
            }
            spec.append("\n");
        }
        
        // Add triggers
        for (ApiTrigger trigger : mapping.getTriggers()) {
            spec.append("  ").append(trigger.getPath()).append(":\n");
            spec.append("    ").append(trigger.getHttpMethod().toLowerCase()).append(":\n");
            spec.append("      summary: ").append(trigger.getName()).append(" trigger\n");
            spec.append("      operationId: ").append(trigger.getId()).append("\n");
            spec.append("      responses:\n");
            spec.append("        200:\n");
            spec.append("          description: Trigger executed successfully\n");
            spec.append("\n");
        }
        
        return spec.toString();
    }
    
    private double calculateMappingQuality(BpmnApiMapping mapping) {
        double quality = 100.0;
        
        // Penalize missing elements
        if (mapping.getEndpoints().isEmpty()) quality -= 30;
        if (mapping.getTriggers().isEmpty()) quality -= 20;
        if (mapping.getDecisions().isEmpty()) quality -= 15;
        if (mapping.getResources().isEmpty()) quality -= 10;
        
        // Penalize poor naming
        for (ApiEndpoint endpoint : mapping.getEndpoints()) {
            if (endpoint.getName() == null || endpoint.getName().trim().isEmpty()) {
                quality -= 5;
            }
        }
        
        // Penalize invalid HTTP methods
        for (ApiEndpoint endpoint : mapping.getEndpoints()) {
            if (!builder.supportedMethods.contains(endpoint.getHttpMethod())) {
                quality -= 10;
            }
        }
        
        return Math.max(quality, 0.0);
    }
    
    private List<String> generateMappingRecommendations(BpmnApiMapping mapping) {
        List<String> recommendations = new ArrayList<>();
        
        if (mapping.getEndpoints().isEmpty()) {
            recommendations.add("Consider adding more user tasks to generate API endpoints");
        }
        
        if (mapping.getQualityScore() < 70) {
            recommendations.add("Improve naming conventions for better API usability");
        }
        
        if (mapping.getEndpoints().size() > 20) {
            recommendations.add("Consider grouping related endpoints into sub-resources");
        }
        
        recommendations.add("Validate generated endpoints against RESTful best practices");
        recommendations.add("Add authentication and authorization to API endpoints");
        recommendations.add("Implement proper error handling and status codes");
        
        return recommendations;
    }
    
    private EndpointDocumentation generateEndpointDocumentation(ApiEndpoint endpoint) {
        EndpointDocumentation doc = new EndpointDocumentation();
        doc.setEndpointId(endpoint.getId());
        doc.setName(endpoint.getName());
        doc.setMethod(endpoint.getHttpMethod());
        doc.setPath(endpoint.getPath());
        doc.setDescription("API endpoint for " + endpoint.getName());
        doc.setParameters(Arrays.asList(
            new ApiParameter("id", "path", "string", "Resource ID", true)
        ));
        return doc;
    }
    
    private String generateWorkflowDocumentation(BpmnApiMapping mapping) {
        StringBuilder doc = new StringBuilder();
        doc.append("# ").append(mapping.getProcessName()).append(" Workflow\n\n");
        doc.append("## Overview\n");
        doc.append("This API implements the workflow defined in the BPMN process: ").append(mapping.getProcessName()).append("\n\n");
        
        doc.append("## Process Flow\n");
        doc.append("1. Start process via POST /").append(mapping.getBasePath()).append("/start\n");
        doc.append("2. Execute tasks using corresponding endpoints\n");
        doc.append("3. Make decisions via decision endpoints\n");
        doc.append("4. Monitor process status via status endpoints\n\n");
        
        return doc.toString();
    }
    
    private Map<String, Object> generateExamples(BpmnApiMapping mapping) {
        Map<String, Object> examples = new HashMap<>();
        
        if (!mapping.getEndpoints().isEmpty()) {
            ApiEndpoint firstEndpoint = mapping.getEndpoints().get(0);
            Map<String, Object> requestExample = new HashMap<>();
            requestExample.put("name", "Example " + firstEndpoint.getName());
            examples.put("request", requestExample);
            
            Map<String, Object> responseExample = new HashMap<>();
            responseExample.put("id", "12345");
            responseExample.put("status", "success");
            responseExample.put("message", firstEndpoint.getName() + " completed successfully");
            examples.put("response", responseExample);
        }
        
        return examples;
    }
    
    private List<String> validateHttpMethods(BpmnApiMapping mapping) {
        List<String> violations = new ArrayList<>();
        
        for (ApiEndpoint endpoint : mapping.getEndpoints()) {
            if (!builder.supportedMethods.contains(endpoint.getHttpMethod())) {
                violations.add("Invalid HTTP method: " + endpoint.getHttpMethod() + " for endpoint " + endpoint.getPath());
            }
        }
        
        return violations;
    }
    
    private List<String> validatePaths(BpmnApiMapping mapping) {
        List<String> violations = new ArrayList<>();
        
        for (ApiEndpoint endpoint : mapping.getEndpoints()) {
            String path = endpoint.getPath();
            
            if (!path.startsWith("/")) {
                violations.add("Path must start with '/': " + path);
            }
            
            if (path.contains("//")) {
                violations.add("Path contains double slashes: " + path);
            }
            
            if (!path.matches("^/[a-zA-Z0-9/\\-_]*$")) {
                violations.add("Path contains invalid characters: " + path);
            }
        }
        
        return violations;
    }
    
    private List<String> validateNamingConventions(BpmnApiMapping mapping) {
        List<String> violations = new ArrayList<>();
        
        for (ApiEndpoint endpoint : mapping.getEndpoints()) {
            if (endpoint.getName() == null || endpoint.getName().trim().isEmpty()) {
                violations.add("Endpoint name is empty: " + endpoint.getPath());
            }
            
            if (endpoint.getName() != null && endpoint.getName().length() > 100) {
                violations.add("Endpoint name too long: " + endpoint.getName());
            }
        }
        
        return violations;
    }
    
    private List<String> validateResourceConsistency(BpmnApiMapping mapping) {
        List<String> violations = new ArrayList<>();
        
        // Check for duplicate paths
        Set<String> seenPaths = new HashSet<>();
        for (ApiEndpoint endpoint : mapping.getEndpoints()) {
            String path = endpoint.getHttpMethod() + " " + endpoint.getPath();
            if (seenPaths.contains(path)) {
                violations.add("Duplicate endpoint: " + path);
            }
            seenPaths.add(path);
        }
        
        return violations;
    }
    
    private double calculateValidationScore(MappingValidationResult result) {
        double score = 100.0;
        
        score -= result.getHttpMethodViolations().size() * 15;
        score -= result.getPathViolations().size() * 10;
        score -= result.getNamingViolations().size() * 5;
        score -= result.getResourceViolations().size() * 20;
        
        return Math.max(score, 0.0);
    }
    
    private List<String> generateValidationRecommendations(MappingValidationResult result) {
        List<String> recommendations = new ArrayList<>();
        
        if (!result.getHttpMethodViolations().isEmpty()) {
            recommendations.add("Use only supported HTTP methods: " + String.join(", ", builder.supportedMethods));
        }
        
        if (!result.getPathViolations().isEmpty()) {
            recommendations.add("Fix path formatting issues - paths must start with '/' and contain only valid characters");
        }
        
        if (!result.getNamingViolations().isEmpty()) {
            recommendations.add("Provide meaningful names for all endpoints and resources");
        }
        
        if (!result.getResourceViolations().isEmpty()) {
            recommendations.add("Remove duplicate endpoints and ensure resource consistency");
        }
        
        recommendations.add("Follow RESTful API design principles");
        recommendations.add("Implement proper status codes and error handling");
        
        return recommendations;
    }
    
    private BpmnApiMapping createErrorMapping(Exception e) {
        BpmnApiMapping errorMapping = new BpmnApiMapping();
        errorMapping.setErrorMessage("Mapping failed: " + e.getMessage());
        errorMapping.setQualityScore(0.0);
        errorMapping.setRecommendations(Arrays.asList("Fix BPMN XML syntax errors", "Validate BPMN process structure"));
        return errorMapping;
    }
    
    // Inner classes for results
    public static class BpmnApiMapping {
        private String processName;
        private String processId;
        private String basePath;
        private List<ApiEndpoint> endpoints;
        private List<ApiTrigger> triggers;
        private List<ApiDecision> decisions;
        private List<ApiResource> resources;
        private String openApiSpec;
        private double qualityScore;
        private List<String> recommendations;
        private String errorMessage;
        
        public BpmnApiMapping() {
            this.endpoints = new ArrayList<>();
            this.triggers = new ArrayList<>();
            this.decisions = new ArrayList<>();
            this.resources = new ArrayList<>();
            this.recommendations = new ArrayList<>();
        }
        
        // Getters and setters
        public String getProcessName() { return processName; }
        public void setProcessName(String processName) { this.processName = processName; }
        
        public String getProcessId() { return processId; }
        public void setProcessId(String processId) { this.processId = processId; }
        
        public String getBasePath() { return basePath; }
        public void setBasePath(String basePath) { this.basePath = basePath; }
        
        public List<ApiEndpoint> getEndpoints() { return endpoints; }
        public void setEndpoints(List<ApiEndpoint> endpoints) { this.endpoints = endpoints; }
        
        public List<ApiTrigger> getTriggers() { return triggers; }
        public void setTriggers(List<ApiTrigger> triggers) { this.triggers = triggers; }
        
        public List<ApiDecision> getDecisions() { return decisions; }
        public void setDecisions(List<ApiDecision> decisions) { this.decisions = decisions; }
        
        public List<ApiResource> getResources() { return resources; }
        public void setResources(List<ApiResource> resources) { this.resources = resources; }
        
        public String getOpenApiSpec() { return openApiSpec; }
        public void setOpenApiSpec(String openApiSpec) { this.openApiSpec = openApiSpec; }
        
        public double getQualityScore() { return qualityScore; }
        public void setQualityScore(double qualityScore) { this.qualityScore = qualityScore; }
        
        public List<String> getRecommendations() { return recommendations; }
        public void setRecommendations(List<String> recommendations) { this.recommendations = recommendations; }
        
        public String getErrorMessage() { return errorMessage; }
        public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
    }
    
    public static class ApiEndpoint {
        private String id;
        private String name;
        private String taskId;
        private String taskType;
        private String httpMethod;
        private String path;
        private List<ApiResponse> responses;
        
        public ApiEndpoint() {
            this.responses = new ArrayList<>();
        }
        
        // Getters and setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        public String getTaskId() { return taskId; }
        public void setTaskId(String taskId) { this.taskId = taskId; }
        
        public String getTaskType() { return taskType; }
        public void setTaskType(String taskType) { this.taskType = taskType; }
        
        public String getHttpMethod() { return httpMethod; }
        public void setHttpMethod(String httpMethod) { this.httpMethod = httpMethod; }
        
        public String getPath() { return path; }
        public void setPath(String path) { this.path = path; }
        
        public List<ApiResponse> getResponses() { return responses; }
        public void setResponses(List<ApiResponse> responses) { this.responses = responses; }
    }
    
    public static class ApiTrigger {
        private String id;
        private String name;
        private String eventId;
        private String triggerType;
        private String httpMethod;
        private String path;
        
        // Getters and setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        public String getEventId() { return eventId; }
        public void setEventId(String eventId) { this.eventId = eventId; }
        
        public String getTriggerType() { return triggerType; }
        public void setTriggerType(String triggerType) { this.triggerType = triggerType; }
        
        public String getHttpMethod() { return httpMethod; }
        public void setHttpMethod(String httpMethod) { this.httpMethod = httpMethod; }
        
        public String getPath() { return path; }
        public void setPath(String path) { this.path = path; }
    }
    
    public static class ApiDecision {
        private String id;
        private String name;
        private String gatewayId;
        private String decisionType;
        private String httpMethod;
        private String path;
        private List<String> possibleOutcomes;
        
        public ApiDecision() {
            this.possibleOutcomes = new ArrayList<>();
        }
        
        // Getters and setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        public String getGatewayId() { return gatewayId; }
        public void setGatewayId(String gatewayId) { this.gatewayId = gatewayId; }
        
        public String getDecisionType() { return decisionType; }
        public void setDecisionType(String decisionType) { this.decisionType = decisionType; }
        
        public String getHttpMethod() { return httpMethod; }
        public void setHttpMethod(String httpMethod) { this.httpMethod = httpMethod; }
        
        public String getPath() { return path; }
        public void setPath(String path) { this.path = path; }
        
        public List<String> getPossibleOutcomes() { return possibleOutcomes; }
        public void setPossibleOutcomes(List<String> possibleOutcomes) { this.possibleOutcomes = possibleOutcomes; }
    }
    
    public static class ApiResource {
        private String id;
        private String name;
        private String subProcessId;
        private String resourceName;
        private String basePath;
        private List<ApiOperation> operations;
        
        public ApiResource() {
            this.operations = new ArrayList<>();
        }
        
        // Getters and setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        public String getSubProcessId() { return subProcessId; }
        public void setSubProcessId(String subProcessId) { this.subProcessId = subProcessId; }
        
        public String getResourceName() { return resourceName; }
        public void setResourceName(String resourceName) { this.resourceName = resourceName; }
        
        public String getBasePath() { return basePath; }
        public void setBasePath(String basePath) { this.basePath = basePath; }
        
        public List<ApiOperation> getOperations() { return operations; }
        public void setOperations(List<ApiOperation> operations) { this.operations = operations; }
    }
    
    public static class ApiResponse {
        private String code;
        private String description;
        private String contentType;
        
        public ApiResponse(String code, String description, String contentType) {
            this.code = code;
            this.description = description;
            this.contentType = contentType;
        }
        
        // Getters
        public String getCode() { return code; }
        public String getDescription() { return description; }
        public String getContentType() { return contentType; }
    }
    
    public static class ApiOperation {
        private String method;
        private String path;
        private String description;
        
        public ApiOperation(String method, String path, String description) {
            this.method = method;
            this.path = path;
            this.description = description;
        }
        
        // Getters
        public String getMethod() { return method; }
        public String getPath() { return path; }
        public String getDescription() { return description; }
    }
    
    public static class ApiParameter {
        private String name;
        private String in;
        private String type;
        private String description;
        private boolean required;
        
        public ApiParameter(String name, String in, String type, String description, boolean required) {
            this.name = name;
            this.in = in;
            this.type = type;
            this.description = description;
            this.required = required;
        }
        
        // Getters
        public String getName() { return name; }
        public String getIn() { return in; }
        public String getType() { return type; }
        public String getDescription() { return description; }
        public boolean isRequired() { return required; }
    }
    
    public static class ApiDocumentation {
        private String processName;
        private String basePath;
        private List<EndpointDocumentation> endpointDocumentation;
        private String workflowDocumentation;
        private Map<String, Object> examples;
        private String errorMessage;
        
        public ApiDocumentation() {
            this.endpointDocumentation = new ArrayList<>();
        }
        
        // Getters and setters
        public String getProcessName() { return processName; }
        public void setProcessName(String processName) { this.processName = processName; }
        
        public String getBasePath() { return basePath; }
        public void setBasePath(String basePath) { this.basePath = basePath; }
        
        public List<EndpointDocumentation> getEndpointDocumentation() { return endpointDocumentation; }
        public void setEndpointDocumentation(List<EndpointDocumentation> endpointDocumentation) { this.endpointDocumentation = endpointDocumentation; }
        
        public String getWorkflowDocumentation() { return workflowDocumentation; }
        public void setWorkflowDocumentation(String workflowDocumentation) { this.workflowDocumentation = workflowDocumentation; }
        
        public Map<String, Object> getExamples() { return examples; }
        public void setExamples(Map<String, Object> examples) { this.examples = examples; }
        
        public String getErrorMessage() { return errorMessage; }
        public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
    }
    
    public static class EndpointDocumentation {
        private String endpointId;
        private String name;
        private String method;
        private String path;
        private String description;
        private List<ApiParameter> parameters;
        
        public EndpointDocumentation() {
            this.parameters = new ArrayList<>();
        }
        
        // Getters and setters
        public String getEndpointId() { return endpointId; }
        public void setEndpointId(String endpointId) { this.endpointId = endpointId; }
        
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        public String getMethod() { return method; }
        public void setMethod(String method) { this.method = method; }
        
        public String getPath() { return path; }
        public void setPath(String path) { this.path = path; }
        
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        
        public List<ApiParameter> getParameters() { return parameters; }
        public void setParameters(List<ApiParameter> parameters) { this.parameters = parameters; }
    }
    
    public static class MappingValidationResult {
        private List<String> httpMethodViolations;
        private List<String> pathViolations;
        private List<String> namingViolations;
        private List<String> resourceViolations;
        private double validationScore;
        private List<String> recommendations;
        private String errorMessage;
        
        public MappingValidationResult() {
            this.httpMethodViolations = new ArrayList<>();
            this.pathViolations = new ArrayList<>();
            this.namingViolations = new ArrayList<>();
            this.resourceViolations = new ArrayList<>();
            this.recommendations = new ArrayList<>();
        }
        
        // Getters and setters
        public List<String> getHttpMethodViolations() { return httpMethodViolations; }
        public void setHttpMethodViolations(List<String> httpMethodViolations) { this.httpMethodViolations = httpMethodViolations; }
        
        public List<String> getPathViolations() { return pathViolations; }
        public void setPathViolations(List<String> pathViolations) { this.pathViolations = pathViolations; }
        
        public List<String> getNamingViolations() { return namingViolations; }
        public void setNamingViolations(List<String> namingViolations) { this.namingViolations = namingViolations; }
        
        public List<String> getResourceViolations() { return resourceViolations; }
        public void setResourceViolations(List<String> resourceViolations) { this.resourceViolations = resourceViolations; }
        
        public double getValidationScore() { return validationScore; }
        public void setValidationScore(double validationScore) { this.validationScore = validationScore; }
        
        public List<String> getRecommendations() { return recommendations; }
        public void setRecommendations(List<String> recommendations) { this.recommendations = recommendations; }
        
        public String getErrorMessage() { return errorMessage; }
        public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
    }
}