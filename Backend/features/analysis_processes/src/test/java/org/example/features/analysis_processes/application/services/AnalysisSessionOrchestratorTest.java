package org.example.features.analysis_processes.application.services;

import org.example.features.analysis_processes.domain.entities.AnalysisProcess;
import org.example.features.analysis_processes.domain.entities.AnalysisSession;
import org.example.features.analysis_processes.domain.repositories.AnalysisProcessRepository;
import org.example.features.analysis_processes.domain.repositories.AnalysisSessionRepository;
import org.example.features.analysis_processes.domain.services.AnalysisProcessService;
import org.example.features.analysis_processes.domain.services.AnalysisSessionService;
import org.example.features.analysis_processes.domain.valueobjects.AnalysisSessionStatus;
import org.example.features.analysis_processes.domain.valueobjects.InputRequirement;
import org.example.features.llm.domain.dto.ChatCompletionResponse;
import org.example.features.llm.domain.services.LLMService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.springframework.beans.factory.ObjectProvider;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

class AnalysisSessionOrchestratorTest {

    @Test
    void generatePlanPersistsStructuredContext(@TempDir Path tempDir) throws IOException {
        InMemoryAnalysisProcessRepository processRepository = new InMemoryAnalysisProcessRepository();
        AnalysisProcess process = processRepository.save(sampleProcess(tempDir));
        AnalysisProcessService processService = new AnalysisProcessService(processRepository);
        AnalysisSessionService sessionService = new AnalysisSessionService(new InMemoryAnalysisSessionRepository());

        LLMService llmService = new StubLlmService("""
            {
              "plan": "1. Execute /health",
              "script": "console.log('health')",
              "summary": "Generated by tests"
            }
            """);
        ProcessAnalysisPlanner planner = new ProcessAnalysisPlanner(new StaticProvider(llmService), false);
        AnalysisSessionOrchestrator orchestrator = new AnalysisSessionOrchestrator(sessionService, processService, planner);

        List<InputRequirement> requirements = List.of(
            new InputRequirement("base_url", "Base URL", "Target base URL", true),
            new InputRequirement("auth_token", "Auth token", "Token for Authorization header", true)
        );
        AnalysisSession session = sessionService.startSession(process.getId(), requirements);
        String sessionId = session.getId();

        orchestrator.provideInputs(sessionId, Map.of("baseUrl", "https://sandbox", "authToken", "demo"));
        AnalysisSession updated = orchestrator.generatePlan(sessionId).orElseThrow();

        assertEquals(AnalysisSessionStatus.WAITING_FOR_TEST, updated.getStatus());
        assertTrue(updated.getContext().containsKey("llmPlan"));
        assertTrue(updated.getContext().containsKey("llmPlanActions"));
        assertEquals("Generated by tests", updated.getContext().get("llmSummary"));
        assertNotNull(updated.getContext().get("testScript"));
    }

    private AnalysisProcess sampleProcess(Path tempDir) throws IOException {
        Path bpmn = Files.createTempFile(tempDir, "process", ".bpmn");
        Files.writeString(bpmn, "<xml>demo</xml>");
        Path openapi = Files.createTempFile(tempDir, "spec", ".yaml");
        Files.writeString(openapi, """
            openapi: 3.0.0
            info:
              title: Orchestrator
              version: 1.0.0
            paths:
              /health: {}
            """);

        return AnalysisProcess.builder()
            .id(UUID.randomUUID().toString())
            .name("Process Orchestrator")
            .description("Orchestrator test process")
            .createdAt(LocalDateTime.now())
            .bpmnDiagramPath(bpmn.toString())
            .openapiSpecPath(openapi.toString())
            .build();
    }

    private static final class InMemoryAnalysisProcessRepository implements AnalysisProcessRepository {

        private final Map<String, AnalysisProcess> storage = new LinkedHashMap<>();

        @Override
        public List<AnalysisProcess> findAll() {
            return new ArrayList<>(storage.values());
        }

        @Override
        public Optional<AnalysisProcess> findById(String id) {
            return Optional.ofNullable(storage.get(id));
        }

        @Override
        public AnalysisProcess save(AnalysisProcess process) {
            if (process.getId() == null) {
                process.setId(UUID.randomUUID().toString());
            }
            if (process.getCreatedAt() == null) {
                process.setCreatedAt(LocalDateTime.now());
            }
            storage.put(process.getId(), process);
            return process;
        }

        @Override
        public void deleteById(String id) {
            storage.remove(id);
        }
    }

    private static final class InMemoryAnalysisSessionRepository implements AnalysisSessionRepository {

        private final Map<String, AnalysisSession> storage = new LinkedHashMap<>();

        @Override
        public List<AnalysisSession> findAll() {
            return new ArrayList<>(storage.values());
        }

        @Override
        public List<AnalysisSession> findByProcessId(String processId) {
            return storage.values().stream()
                .filter(session -> processId.equals(session.getProcessId()))
                .toList();
        }

        @Override
        public Optional<AnalysisSession> findById(String sessionId) {
            return Optional.ofNullable(storage.get(sessionId));
        }

        @Override
        public AnalysisSession save(AnalysisSession session) {
            if (session.getId() == null) {
                session.setId(UUID.randomUUID().toString());
            }
            if (session.getCreatedAt() == null) {
                session.setCreatedAt(LocalDateTime.now());
            }
            session.setUpdatedAt(LocalDateTime.now());
            storage.put(session.getId(), session);
            return session;
        }
    }

    private record StaticProvider(LLMService value) implements ObjectProvider<LLMService> {
        @Override
        public LLMService getObject(Object... args) {
            return value;
        }

        @Override
        public LLMService getObject() {
            return value;
        }

        @Override
        public LLMService getIfAvailable() {
            return value;
        }

        @Override
        public LLMService getIfUnique() {
            return value;
        }

        @Override
        public void forEach(Consumer<? super LLMService> action) {
            if (value != null) {
                action.accept(value);
            }
        }

        @Override
        public Stream<LLMService> stream() {
            return value == null ? Stream.empty() : Stream.of(value);
        }
    }

    private static final class StubLlmService implements LLMService {
        private final String payload;

        private StubLlmService(String payload) {
            this.payload = payload;
        }

        @Override
        public boolean isAvailable() {
            return true;
        }

        @Override
        public CompletableFuture<ChatCompletionResponse> chatCompletion(org.example.features.llm.domain.dto.ChatCompletionRequest request) {
            ChatCompletionResponse.Message message = new ChatCompletionResponse.Message("assistant", payload);
            ChatCompletionResponse.Choice choice = new ChatCompletionResponse.Choice(0, message, "stop");
            ChatCompletionResponse response = new ChatCompletionResponse();
            response.setChoices(List.of(choice));
            return CompletableFuture.completedFuture(response);
        }

        @Override
        public String getProviderName() {
            return "stub";
        }

        @Override
        public String getStatus() {
            return "ready";
        }

        @Override
        public String[] getSupportedModels() {
            return new String[] {"stub"};
        }
    }
}
